**C++ learning**

C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。

**注意：使用静态类型的编程语言是在编译时执行类型检查**，而不是在运行时执行类型检查。

# 面向对象开发的四大特性：

- **封装（Encapsulation）**：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。
- **继承（Inheritance）**：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。
- **多态（Polymorphism）**：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。
- **抽象（Abstraction）**：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。

# 标准库

标准的 C++ 由三个重要部分组成：

- 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。
- C++ 标准库，提供了大量的函数，用于操作文件、字符串等。
- 标准模板库（STL），提供了大量的方法，用于操作数据结构等。

## 样例程序

```cpp
#include <iostream>
using namespace std;
int main()
{
    cout << "Hello, world!" << endl;
    return 0;
}
```



# 环境

## 文本编辑器

通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。

C++ 程序的源文件通常使用扩展名 **.cpp**（默认）、**.cp** 或 **.c**。

## C++ 编译器

C++ 编译器用于把源代码编译成最终的可执行程序。

如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：

- 打开一个文本编辑器，添加上述代码。
- 保存文件为 **hello.cpp**。
- 打开命令提示符，进入到保存文件所在的目录。
- 键入 'g++ hello.cpp '，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并**生成 a.out 可执行文件**。
- 现在，键入 ' a.out' 来运行程序。
- 您可以看到屏幕上显示 ' Hello World '。

# 基本语法

什么是类、对象，方法、即时变量：

- **对象 -** 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。
- **类 -** 类可以定义为描述对象行为/状态的模板/蓝图。
- **方法 -** 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。
- **即时变量 -** 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。



## 分号 & 语句块

在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。

语句块是一组使用大括号括起来的按逻辑连接的语句。例如：

```cpp
{
   cout << "Hello World"; // 输出 Hello World
   return 0;
}
```

C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。

```cpp
x = y; y = y+1; add(x, y);
```



## 标识符

C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。

C++ 标识符内**不允许出现标点字符**，比如 @、& 和 %。

C++ 是**区分大小写**的编程语言。



## 关键字（保留字）

保留字不能作为常量名、变量名或其他标识符名称。

| asm          | else      | new              | this     |
| ------------ | --------- | ---------------- | -------- |
| auto         | enum      | operator         | throw    |
| bool         | explicit  | private          | true     |
| break        | export    | protected        | try      |
| case         | extern    | public           | typedef  |
| catch        | false     | register         | typeid   |
| char         | float     | reinterpret_cast | typename |
| class        | for       | return           | union    |
| const        | friend    | short            | unsigned |
| const_cast   | goto      | signed           | using    |
| continue     | if        | sizeof           | virtual  |
| default      | inline    | static           | void     |
| delete       | int       | static_cast      | volatile |
| do           | long      | struct           | wchar_t  |
| double       | mutable   | switch           | while    |
| dynamic_cast | namespace | template         |          |



## 三字符组

三字符组就是用于**表示另一个字符的三个字符序列**，又称为三字符序列。三字符序列**总是以两个问号开头**。

三字符序列不太常见，但 C++ 标准**允许把某些字符指定为三字符序列**。以前为了表示键盘上没有的字符，这是必不可少的一种方法。

三字符序列可以**出现在任何地方**，包括字符串、字符序列、注释和预处理指令。

下面列出了最常用的三字符序列：

| 三字符组 | 替换 |
| :------- | :--- |
| ??=      | #    |
| ??/      | \    |
| ??'      | ^    |
| ??(      | [    |
| ??)      | ]    |
| ??!      | \|   |
| ??<      | {    |
| ??>      | }    |
| ??-      | ~    |

如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接："...?""?..."或者转义序列："...?\?..."。



## 空格

只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。

在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：

```cpp
int age;
```

在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：

```cpp
fruit = apples + oranges;   // 获取水果的总数
```

fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是**为了增强可读性**，您可以根据需要适当增加一些空格。



# 注释

C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。

C++ 注释一般有两种：

- **//** - 一般用于单行注释。
- /*** ... \*/** - 一般用于多行注释。

注释以 **//** 开始，直到行末为止。

在 **/\*** 和 ***/** 注释内部，**//** 字符没有特殊的含义。在 **//** 注释内，**/\*** 和 ***/** 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如：

```cpp
/* 用于输出 Hello World 的注释  

cout << "Hello World"; // 输出 Hello World  

*/
```

块注释符（/*...*/）是**不可以嵌套**使用的。



# 数据类型

变量保留的是它所存储的值的内存位置。


## 基本的内置类型

C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：

| 类型     | 关键字  | 描述                                                         |
| :------- | :------ | ------------------------------------------------------------ |
| 布尔型   | bool    | 布尔类型，存储值 true 或 false，占用 1 个字节。              |
| 字符型   | char    | 字符类型，用于存储 ASCII 字符，通常占用 1 个字节。           |
| 整型     | int     | 整数类型，通常用于存储普通整数，通常占用 4 个字节。          |
| 浮点型   | float   | 单精度浮点值，用于存储单精度浮点数。单精度是这样的格式，1 位符号，8 位指数，23 位小数，通常占用4个字节。<br />![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png) |
| 双浮点型 | double  | 双精度浮点值，用于存储双精度浮点数。双精度是 1 位符号，11 位指数，52 位小数，通常占用 8 个字节。<br />![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png) |
| 无类型   | void    | 表示类型的缺失。                                             |
| 宽字符型 | wchar_t | 宽字符类型，用于存储更大范围的字符，通常占用 2 个或 4 个字节。 |

其实 wchar_t 是这样来的：

```c++
typedef short int wchar_t;
```

所以 wchar_t 实际上的空间是和 short int 一样。

类型修饰符：

| 修饰符     | 描述                                   | 示例                   |
| :--------- | :------------------------------------- | :--------------------- |
| `signed`   | 表示有符号类型（默认）                 | `signed int x = -10;`  |
| `unsigned` | 表示无符号类型                         | `unsigned int y = 10;` |
| `short`    | 表示短整型                             | `short int z = 100;`   |
| `long`     | 表示长整型                             | `long int a = 100000;` |
| `const`    | 表示常量，值不可修改                   | `const int b = 5;`     |
| `volatile` | 表示变量可能被意外修改，禁止编译器优化 | `volatile int c = 10;` |
| `mutable`  | 表示类成员可以在 `const` 对象中修改    | `mutable int counter;` |

下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。

**注意：**不同系统会有所差异，**一字节为 8 位**。

**注意：**默认情况下，int、short、long都是带符号的，即 signed。

**注意：**long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。

| 数据类型             | 描述                                 | 大小（字节） | 范围/取值示例                                           |
| :------------------- | :----------------------------------- | :----------- | :------------------------------------------------------ |
| `bool`               | 布尔类型，表示真或假                 | 1            | `true` 或 `false`                                       |
| `char`               | 字符类型，通常用于存储 ASCII 字符    | 1            | -128 到 127 或 0 到 255                                 |
| `signed char`        | 有符号字符类型                       | 1            | -128 到 127                                             |
| `unsigned char`      | 无符号字符类型                       | 1            | 0 到 255                                                |
| `wchar_t`            | 宽字符类型，用于存储 Unicode 字符    | 2 或 4       | 取决于平台                                              |
| `char16_t`           | 16 位 Unicode 字符类型（C++11 引入） | 2            | 0 到 65,535                                             |
| `char32_t`           | 32 位 Unicode 字符类型（C++11 引入） | 4            | 0 到 4,294,967,295                                      |
| `short`              | 短整型                               | 2            | -32,768 到 32,767                                       |
| `unsigned short`     | 无符号短整型                         | 2            | 0 到 65,535                                             |
| `int`                | 整型                                 | 4            | -2,147,483,648 到 2,147,483,647                         |
| `unsigned int`       | 无符号整型                           | 4            | 0 到 4,294,967,295                                      |
| `long`               | 长整型                               | 4 或 8       | 取决于平台                                              |
| `unsigned long`      | 无符号长整型                         | 4 或 8       | 取决于平台                                              |
| `long long`          | 长长整型（C++11 引入）               | 8            | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |
| `unsigned long long` | 无符号长长整型（C++11 引入）         | 8            | 0 到 18,446,744,073,709,551,615                         |
| `float`              | 单精度浮点数                         | 4            | 约 ±3.4e±38（6-7 位有效数字）                           |
| `double`             | 双精度浮点数                         | 8            | 约 ±1.7e±308（15 位有效数字）                           |
| `long double`        | 扩展精度浮点数                       | 8、12 或 16  | 取决于平台                                              |



## C++11 新增类型

| 数据类型                | 描述                               | 示例                                           |
| :---------------------- | :--------------------------------- | :--------------------------------------------- |
| `auto`                  | 自动类型推断                       | `auto x = 10;`                                 |
| `decltype`              | 获取表达式的类型                   | `decltype(x) y = 20;`                          |
| `nullptr`               | 空指针常量                         | `int* ptr = nullptr;`                          |
| `std::initializer_list` | 初始化列表类型                     | `std::initializer_list<int> list = {1, 2, 3};` |
| `std::tuple`            | 元组类型，可以存储多个不同类型的值 | `std::tuple<int, float, char> t(1, 2.0, 'a');` |



## 派生数据类型

| 数据类型 | 描述                                           | 示例                               |
| :------- | :--------------------------------------------- | :--------------------------------- |
| `数组`   | 相同类型元素的集合                             | `int arr[5] = {1, 2, 3, 4, 5};`    |
| `指针`   | 存储变量内存地址的类型                         | `int* ptr = &x;`                   |
| `引用`   | 变量的别名                                     | `int& ref = x;`                    |
| `函数`   | 函数类型，表示函数的签名                       | `int func(int a, int b);`          |
| `结构体` | 用户定义的数据类型，可以包含多个不同类型的成员 | `struct Point { int x; int y; };`  |
| `类`     | 用户定义的数据类型，支持封装、继承和多态       | `class MyClass { ... };`           |
| `联合体` | 多个成员共享同一块内存                         | `union Data { int i; float f; };`  |
| `枚举`   | 用户定义的整数常量集合                         | `enum Color { RED, GREEN, BLUE };` |


## 类型别名

| 别名      | 描述                             | 示例                 |
| :-------- | :------------------------------- | :------------------- |
| `typedef` | 为现有类型定义别名               | `typedef int MyInt;` |
| `using`   | 为现有类型定义别名（C++11 引入） | `using MyInt = int;` |



## 标准库类型

| 数据类型      | 描述                       | 示例                                |
| :------------ | :------------------------- | :---------------------------------- |
| `std::string` | 字符串类型                 | `std::string s = "Hello";`          |
| `std::vector` | 动态数组                   | `std::vector<int> v = {1, 2, 3};`   |
| `std::array`  | 固定大小数组（C++11 引入） | `std::array<int, 3> a = {1, 2, 3};` |
| `std::pair`   | 存储两个值的容器           | `std::pair<int, float> p(1, 2.0);`  |
| `std::map`    | 键值对容器                 | `std::map<int, std::string> m;`     |
| `std::set`    | 唯一值集合                 | `std::set<int> s = {1, 2, 3};`      |



## 类型转换

类型转换是将一个数据类型的值转换为另一种数据类型的值。

C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。

### 静态转换（Static Cast）

静态转换是将一种数据类型的值**强制转换**为另一种数据类型的值。

静态转换通常*用于比较类型相似的对象之间的转换*，例如将 int 类型转换为 float 类型。

**静态转换不进行任何运行时类型检查**，因此可能会导致运行时错误。

#### 实例

```c++
int i = 10; float f = static_cast<float>(i); // 静态将int类型转换为float类型
```



### 动态转换（Dynamic Cast）

动态转换（dynamic_cast）是 C++ 中用于在继承层次结构中进行向下转换（downcasting）的一种机制。

动态转换**通常用于将一个基类指针或引用转换为派生类指针或引用**。

动态转换在**运行时进行类型检查**。如果转换失败，对于指针类型会返回 nullptr，对于引用类型则会抛出 std::bad_cast 异常。

**语法：**

```c++
dynamic_cast<目标类型>(表达式)
```

- **目标类型**：必须是指针或引用类型。
- **表达式**：需要转换的基类指针或引用。

#### 实例：指针类型的动态转换

```cpp
#include <iostream>

class Base {
public:
    virtual ~Base() = default; // 基类必须具有虚函数
};

class Derived : public Base {
public:
    void show() {
        std::cout << "Derived class method" << std::endl;
    }
};

int main() {
    Base* ptr_base = new Derived; // 基类指针指向派生类对象

    // 将基类指针转换为派生类指针
    Derived* ptr_derived = dynamic_cast<Derived*>(ptr_base);
     
    if (ptr_derived) {
        ptr_derived->show(); // 成功转换，调用派生类方法
    } else {
        std::cout << "Dynamic cast failed!" << std::endl;
    }
     
    delete ptr_base;
    return 0;

}
```

输出：

```cpp
Derived class method
```

#### 实例：引用类型的动态转换

```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual ~Base() = default; // 基类必须具有虚函数
};

class Derived : public Base {
public:
    void show() {
        std::cout << "Derived class method" << std::endl;
    }
};

int main() {
    Derived derived_obj;
    Base& ref_base = derived_obj; // 基类引用绑定到派生类对象

    try {
        // 将基类引用转换为派生类引用
        Derived& ref_derived = dynamic_cast<Derived&>(ref_base);
        ref_derived.show(); // 成功转换，调用派生类方法
    } catch (const std::bad_cast& e) {
        std::cout << "Dynamic cast failed: " << e.what() << std::endl;
    }
    
    return 0;

}
```

输出：

```cpp
Derived class method
```

| 特性               | 指针类型                 | 引用类型                  |
| :----------------- | :----------------------- | :------------------------ |
| **转换失败返回值** | 返回 `nullptr`           | 抛出 `std::bad_cast` 异常 |
| **适用场景**       | 向下转换、运行时类型检查 | 向下转换、运行时类型检查  |
| **性能开销**       | 较高                     | 较高                      |
| **基类要求**       | 必须具有虚函数           | 必须具有虚函数            |

### 常量转换（Const Cast）

常量转换*用于将 const 类型的对象转换为非 const 类型的对象*。

常量转换**只能用于转换掉 const 属性，不能改变对象的类型**。

#### 实例

```cpp
const int i = 10;
int& r = const_cast<int&>(i); // 常量转换，将const int转换为int
```



### 重新解释转换（Reinterpret Cast）

重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常*用于在不同的数据类型之间进行转换*。

重新解释转换**不进行任何类型检查**，因此可能会导致未定义的行为。

#### 实例

```cpp
int i = 10;
float f = reinterpret_cast<float&>(i); // 重新解释将int类型转换为float类型
```



# 变量定义

```cpp
int    i, j, k;
char   c, ch;
float  f, salary;
double d;
```

```c++
extern int d = 3, f = 5;    // d 和 f 的声明 
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z
char x = 'x';               // 变量 x 的值为 'x'
```

不带初始化的定义：带有静态存储持续时间的变量会被**隐式初始化为 NULL**（所有字节的值都是 0），其他所有变量的初始值是未定义的。



## 变量声明

变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。**变量声明只在编译时有它的意义**，在程序连接时编译器需要实际的变量声明。

当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 **extern** 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。

变量在头部就已经被声明，但它们是在主函数内被定义和初始化的：

```c++
#include <iostream>
using namespace std;
 
// 变量声明
extern int a, b;
extern int c;
extern float f;
  
int main ()
{
  // 变量定义
  int a, b;
  int c;
  float f;
 
  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c << endl ;
 
  f = 70.0/3.0;
  cout << f << endl ;
 
  return 0;
}
```

同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：

```c++
// 函数声明
int func();
 
int main()
{
    // 函数调用
    int i = func();
}
 
// 函数定义
int func()
{
    return 0;
}
```



## 左值（Lvalues）和右值（Rvalues）

C++ 中有两种类型的表达式：

- **左值（lvalue）：**指向**内存位置的表达式**被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- **右值（rvalue）：**术语右值（rvalue）指的是**存储在内存中某些地址的数值**。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但**不能出现在赋值号的左边**。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：

```c++
int g = 20;
```

但是下面这个就不是一个有效的语句，会生成编译时错误：

```c++
10 = 20;
```



# 变量作用域

一般来说有三个地方可以定义变量：

- 在函数或一个代码块内部声明的变量，称为**局部变量**。
- 在函数参数的定义中声明的变量，称为**形式参数**。
- 在所有函数外部声明的变量，称为**全局变量**。

作用域是程序的一个区域，变量的作用域可以分为以下几种：

- **局部作用域**：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。
- **全局作用域**：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。
- **块作用域**：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。
- **类作用域**：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。

**注意：**如果在内部作用域中声明的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部作用域中的变量。

块作用域指的是在代码块内部声明的变量：

```c++
#include <iostream>

int main() {
    int a = 10;
    {
        int a = 20;  // 块作用域变量
        std::cout << "块变量: " << a << std::endl;
    }
    std::cout << "外部变量: " << a << std::endl;
    return 0;
}
```



# 常量

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。

常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。

常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

## 整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：`0x` 或 `0X` 表示十六进制，`0` 表示八进制，不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

```cpp
212         // 合法的
215u        // 合法的
0xFeeL      // 合法的
078         // 非法的：8 不是八进制的数字
032UU       // 非法的：不能重复后缀

85         // 十进制
0213       // 八进制 
0x4b       // 十六进制 
30         // 整数 
30u        // 无符号整数 
30l        // 长整数 
30ul       // 无符号长整数
```

## 浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 `e` 或 `E` 引入的。

```cpp
3.14159       // 合法的 
314159E-5L    // 合法的 
510E          // 非法的：不完整的指数
210f          // 非法的：没有小数或指数
.e55          // 非法的：缺少整数或分数
```

## 布尔常量

布尔常量共有两个，它们都是标准的 C++ 关键字：

- true 值代表真。
- false 值代表假。
我们不应把 true 的值看成 1，把 false 的值看成 0。


## 字符常量

字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 **char** 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：

| 转义序列   | 含义                       |
| :--------- | :------------------------- |
| `\\`         | \ 字符                     |
| `\'`         | ' 字符                     |
| `\"`         | " 字符                     |
| `\?`         | ? 字符                     |
| `\a`         | 警报铃声                   |
| `\b`         | 退格键                     |
| `\f`         | 换页符                     |
| `\n`         | 换行符                     |
| `\r`         | 回车                       |
| `\t`         | 水平制表符                 |
| `\v`         | 垂直制表符                 |
| `\ooo`       | 一到三位的八进制数         |
| `\xhh . . .` | 一个或多个数字的十六进制数 |



## 字符串常量

字符串字面值或常量是括在双引号 **""** 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以使用 \ 做分隔符，把一个很长的字符串常量进行分行。

下面的实例显示了一些字符串常量：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string greeting = "hello, runoob";
    cout << greeting;
    cout << "\n";     // 换行符
    string greeting2 = "hello, \
                        runoob";
    cout << greeting2;
    return 0;
}
```



## 定义常量

在 C++ 中，有两种简单的定义常量的方式：

- 使用 **#define** 预处理器。
- 使用 **const** 关键字。

### #define

```cpp
#include <iostream>
using namespace std;
 
#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'
 
int main()
{
 
   int area;  
   
   area = LENGTH * WIDTH;
   cout << area;
   cout << NEWLINE;
   return 0;
}
```

### const

```cpp
#include <iostream>
using namespace std;
 
int main()
{
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   cout << area;
   cout << NEWLINE;
   return 0;
}
```



# 类型限定符

类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。

| 限定符   | 含义                                                         |
| :------- | :----------------------------------------------------------- |
| const    | **const** 定义常量，表示该变量的值不能被修改。               |
| volatile | 修饰符 **volatile** 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程。。 |
| restrict | 由 **restrict** 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 |
| mutable  | mutable 用于修饰类的成员变量。被 mutable 修饰的成员变量可以被修改，即使它们所在的对象是 const 的。 |
| static   | 用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。 |
| register | 用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率。 |

**register在 C++11 中被标记为弃用(deprecated) 在 C++17 中被正式移除。**


## 运算符

运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：

- 算术运算符
- 关系运算符
- 逻辑运算符
- 位运算符
- 赋值运算符
- 杂项运算符

### 算术运算符

假设变量 A 的值为 10，变量 B 的值为 20，则：

| 运算符 | 描述                                                         | 实例             |
| :----- | :----------------------------------------------------------- | :--------------- |
| +      | 把两个操作数相加                                             | A + B 将得到 30  |
| -      | 从第一个操作数中减去第二个操作数                             | A - B 将得到 -10 |
| *      | 把两个操作数相乘                                             | A * B 将得到 200 |
| /      | 分子除以分母                                                 | B / A 将得到 2   |
| %      | 取模运算符，整除后的余数                                     | B % A 将得到 0   |
| ++     | [自增运算符](https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html)，整数值增加 1 | A++ 将得到 11    |
| --     | [自减运算符](https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html)，整数值减少 1 | A-- 将得到 9     |

### 关系运算符

假设变量 A 的值为 10，变量 B 的值为 20，则：

| 运算符 | 描述                                                         | 实例              |
| :----- | :----------------------------------------------------------- | :---------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 不为真。 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。   |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 不为真。  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。    |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。   |

### 逻辑运算符

假设变量 A 的值为 1，变量 B 的值为 0，则：

| 运算符 | 描述                                                         | 实例                 |
| :----- | :----------------------------------------------------------- | :------------------- |
| &&     | 称为逻辑**与**运算符。如果两个操作数都 true，则条件为 true。 | (A && B) 为 false。  |
| \|\|   | 称为逻辑**或**运算符。如果两个操作数中有任意一个 true，则条件为 true。 | (A \|\| B) 为 true。 |
| !      | 称为逻辑**非**运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 | !(A && B) 为 true。  |

### 位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p    | q    | p & q | p \| q | p ^ q |
| :--- | :--- | :---- | :----- | :---- |
| 0    | 0    | 0     | 0      | 0     |
| 0    | 1    | 0     | 1      | 1     |
| 1    | 1    | 1     | 1      | 0     |
| 1    | 0    | 0     | 1      | 1     |

假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：

A = 0011 1100

B = 0000 1101

\-----------------

A&B = 0000 1100

A|B = 0011 1101

A^B = 0011 0001

~A = 1100 0011

假设变量 A 的值为 60，变量 B 的值为 13，则：

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与操作，按二进制位进行"与"运算。运算规则：`0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |
| \|     | 按位或运算符，按二进制位进行"或"运算。运算规则：`0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \| B) 将得到 61，即为 0011 1101                           |
| ^      | 异或运算符，按二进制位进行"异或"运算。运算规则：`0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |
| ~      | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=-2;    ~0=-1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| <<     | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |
| >>     | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 | A >> 2 将得到 15，即为 0000 1111                             |

### 赋值运算符

下表列出了 C++ 支持的赋值运算符：

| 运算符 | 描述                                                         | 实例                            |
| :----- | :----------------------------------------------------------- | :------------------------------ |
| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |
| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |
| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |
| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |
| \|=    | 按位或且赋值运算符                                           | C \|= 2 等同于 C = C \| 2       |

### 杂项运算符

| 运算符               | 描述                                                         |
| :------------------- | :----------------------------------------------------------- |
| sizeof               | [sizeof 运算符](https://www.runoob.com/cplusplus/cpp-sizeof-operator.html)返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 |
| Condition ? X : Y    | [条件运算符](https://www.runoob.com/cplusplus/cpp-conditional-operator.html)。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 |
| ,                    | [逗号运算符](https://www.runoob.com/cplusplus/cpp-comma-operator.html)会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 |
| .（点）和 ->（箭头） | [成员运算符](https://www.runoob.com/cplusplus/cpp-member-operators.html)用于引用类、结构和共用体的成员。 |
| Cast                 | [强制转换运算符](https://www.runoob.com/cplusplus/cpp-casting-operators.html)把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 |
| &                    | [指针运算符 &](https://www.runoob.com/cplusplus/cpp-pointer-operators.html) 返回变量的地址。例如 &a; 将给出变量的实际地址。 |
| *                    | [指针运算符 *](https://www.runoob.com/cplusplus/cpp-pointer-operators.html) 指向一个变量。例如，*var; 将指向变量 var。 |

### 运算符优先级

下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。

| 类别       | 运算符                            | 结合性   |
| :--------- | :-------------------------------- | :------- |
| 后缀       | () [] -> . ++ - -                 | 从左到右 |
| 一元       | + - ! ~ ++ - - (type)* & sizeof   | 从右到左 |
| 乘除       | * / %                             | 从左到右 |
| 加减       | + -                               | 从左到右 |
| 移位       | << >>                             | 从左到右 |
| 关系       | < <= > >=                         | 从左到右 |
| 相等       | == !=                             | 从左到右 |
| 位与 AND   | &                                 | 从左到右 |
| 位异或 XOR | ^                                 | 从左到右 |
| 位或 OR    | \|                                | 从左到右 |
| 逻辑与 AND | &&                                | 从左到右 |
| 逻辑或 OR  | \|\|                              | 从左到右 |
| 条件       | ?:                                | 从右到左 |
| 赋值       | = += -= *= /= %=>>= <<= &= ^= \|= | 从右到左 |
| 逗号       | ，                                 | 从左到右 |



## 循环

### 循环类型

C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。

| 循环类型                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [while 循环](https://www.runoob.com/cplusplus/cpp-while-loop.html) | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 |
| [for 循环](https://www.runoob.com/cplusplus/cpp-for-loop.html) | 多次执行一个语句序列，简化管理循环变量的代码。               |
| [do...while 循环](https://www.runoob.com/cplusplus/cpp-do-while-loop.html) | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。    |
| [嵌套循环](https://www.runoob.com/cplusplus/cpp-nested-loops.html) | 您可以在 while、for 或 do..while 循环内使用一个或多个循环。  |

### 循环控制语句

| 控制语句                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [break 语句](https://www.runoob.com/cplusplus/cpp-break-statement.html) | 终止 **loop** 或 **switch** 语句，程序流将继续执行紧接着 loop 或 switch 的**下一条语句**。 |
| [continue 语句](https://www.runoob.com/cplusplus/cpp-continue-statement.html) | 引起循环跳过主体的剩余部分，**立即重新开始测试条件**。       |
| [goto 语句](https://www.runoob.com/cplusplus/cpp-goto-statement.html) | 将控制转移到被标记的语句。但是**不建议**在程序中使用 goto 语句。 |

一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。

**注意：**您可以按 Ctrl + C 键终止一个无限循环。



## 判断

C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。

| 语句                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [if 语句](https://www.runoob.com/cplusplus/cpp-if.html)      | 一个 **if 语句** 由一个布尔表达式后跟一个或多个语句组成。    |
| [if...else 语句](https://www.runoob.com/cplusplus/cpp-if-else.html) | 一个 **if 语句** 后可跟一个可选的 **else 语句**，else 语句在布尔表达式为假时执行。 |
| [嵌套 if 语句](https://www.runoob.com/cplusplus/cpp-nested-if.html) | 您可以在一个 **if** 或 **else if** 语句内使用另一个 **if** 或 **else if** 语句。 |
| [switch 语句](https://www.runoob.com/cplusplus/cpp-switch.html) | 一个 **switch** 语句允许测试一个变量等于多个值时的情况。     |
| [嵌套 switch 语句](https://www.runoob.com/cplusplus/cpp-nested-switch.html) | 您可以在一个 **switch** 语句内使用另一个 **switch** 语句。   |



## 函数

函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。

C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 **strcat()** 用来连接两个字符串，函数 **memcpy()** 用来复制内存到另一个位置。

函数还有很多叫法，比如方法、子例程或程序，等等。

在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：

- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，**函数可能不包含参数**。
- **函数主体：**函数主体包含一组定义函数执行任务的语句。

```cpp
// 函数返回两个数中较大的那个数
 
int max(int num1, int num2) 
{
   // 局部变量声明
   int result;
 
   if (num1 > num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}
```

### 函数声明

函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

针对上面定义的函数 max()，以下是函数声明：

```cpp
int max(int num1, int num2);
```

在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：

```cpp
int max(int, int);
```

当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。

### 函数参数

当调用函数时，有三种向函数传递参数的方式：

| 调用类型                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [传值调用](https://www.runoob.com/cplusplus/cpp-function-call-by-value.html) | 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |
| [指针调用](https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html) | 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |
| [引用调用](https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html) | 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |

默认情况下，C++ 使用**传值调用**来传递参数。

### Lambda 函数与表达式

C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。

Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。

Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:

```c++
[capture](parameters)->return-type{body}
```

例如：

```c++
[](int x, int y){ return x < y ; }
```

如果没有返回值可以表示为：

```c++
[capture](parameters){body}
```

例如：

```c++
[]{ ++global_x; } 
```

在一个更为复杂的例子中，返回类型可以被明确的指定如下：

```c++
[](int x, int y) -> int { int z = x + y; return z + x; }
```

本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。

如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。

在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：

```c++
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```

另外有一点需要注意。对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：

```c++
[this]() { this->someFunc(); }();
```



## 数字

### 数学运算
内置函数可以引用数学头文件 <cmath>。

| 序号 | 函数 & 描述 |
| ---- | ---- |
| 1 | `double cos(double);` <br> 该函数返回弧度角（double 型）的余弦。 |
| 2 | `double sin(double);` <br> 该函数返回弧度角（double 型）的正弦。 |
| 3 | `double tan(double);` <br> 该函数返回弧度角（double 型）的正切。 |
| 4 | `double log(double);` <br> 该函数返回参数的自然对数。 |
| 5 | `double pow(double, double);` <br> 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 |
| 6 | `double hypot(double, double);` <br> 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 |
| 7 | `double sqrt(double);` <br> 该函数返回参数的平方根。 |
| 8 | `int abs(int);` <br> 该函数返回整数的绝对值。 |
| 9 | `double fabs(double);` <br> 该函数返回任意一个浮点数的绝对值。 |
| 10 | `double floor(double);` <br> 该函数返回一个小于或等于传入参数的最大整数。 |

### 随机数

关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 **srand()** 函数。一般种子函数配合时间time()函数使用。

```cpp
#include <iostream>
#include <ctime>
#include <cstdlib>
 
using namespace std;
 
int main ()
{
   int i,j;
 
   // 设置种子
   srand( (unsigned)time( NULL ) );
 
   /* 生成 10 个随机数 */
   for( i = 0; i < 10; i++ )
   {
      // 生成实际的随机数
      j= rand();
      cout <<"随机数： " << j << endl;
   }
 
   return 0;
}
```

## 数组

C++ 支持**数组**数据结构，它可以存储一个**固定大小**的**相同类型元素**的**顺序集合**。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。

*所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。*

声明一个类型为 double 的包含 10 个元素的数组 balance：
```cpp
double balance[10];
```

### 初始化数组

```cpp
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

大括号 { } 之间的值的数目**不能大于**我们在数组声明时在方括号 [ ] 中指定的元素数目。

如果您**省略**掉了数组的**大小**，数组的大小则为初始化时元素的个数。因此，如果：

```cpp
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

```cpp
balance[4] = 50.0;
```

### 访问数组元素

数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：

```cpp
double salary = balance[9];
```

### 多维数组

多维数组最简单的形式是二维数组。一个带有 3 行 4 列的数组：
```cpp
int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
```
等价于：
```cpp
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

### 指向数组的指针

数组名是指向数组中第一个元素的常量指针。
```cpp
double runoobAarray[50];
```
runoobAarray 是一个指向 `&runoobAarray[0]` 的指针，即数组 runoobAarray 的第一个元素的地址。`*(runoobAarray + 4)` 是一种访问 `runoobAarray[4]` 数据的合法方式。

```cpp
#include <iostream>
using namespace std;
 
int main ()
{
   // 带有 5 个元素的双精度浮点型数组
   double runoobAarray[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
   double *p;
 
   p = runoobAarray;
 
   // 输出数组中每个元素的值
   cout << "使用指针的数组值 " << endl; 
   for ( int i = 0; i < 5; i++ )
   {
       cout << "*(p + " << i << ") : ";
       cout << *(p + i) << endl;
   }
 
   cout << "使用 runoobAarray 作为地址的数组值 " << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "*(runoobAarray + " << i << ") : ";
       cout << *(runoobAarray + i) << endl;
   }
 
   return 0;
}
```

```cpp
使用指针的数组值 
*(p + 0) : 1000
*(p + 1) : 2
*(p + 2) : 3.4
*(p + 3) : 17
*(p + 4) : 50
使用 runoobAarray 作为地址的数组值 
*(runoobAarray + 0) : 1000
*(runoobAarray + 1) : 2
*(runoobAarray + 2) : 3.4
*(runoobAarray + 3) : 17
*(runoobAarray + 4) : 50
```

### 传递数组给函数

可以通过指定不带索引的数组名来传递一个指向数组的指针。C++ 传数组给一个函数，数组类型自动转换为指针类型，因而传的实际是地址。必须以下面三种方式来声明函数形式参数:
形式参数是一个指针：
```cpp
void myFunction(int *param)
{
。
。
。
}
```
形式参数是一个已定义大小的数组：
```cpp
void myFunction(int param[10])
{
.
.
.
}
```
形式参数是一个未定义大小的数组：
```cpp
void myFunction(int param[])
{
。
。
。
}
```
就函数而言，数组的长度是无关紧要的，因为 C++ 不会对形式参数执行边界检查。

### 从函数返回数组
C++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。

如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下：
```cpp
int* myFunction()
{
   int myArray[3] = {1, 2, 3};
   return myArray;
}
```
注意：你不能简单地返回指向局部数组的指针，因为当函数结束时，局部数组将被销毁，指向它的指针将变得无效。
C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。

为了避免以上情况，可以使用**静态数组**或者**动态分配数组**。
```cpp
int* myFunction()
{
   static int myArray[3] = {1, 2, 3};
   return myArray;
}
```

使用动态分配数组需要在函数内部使用 new 运算符来分配一个数组，并在函数结束时使用 delete 运算符释放该数组，例如：
```cpp
int* myFunction()
{
   int* myArray = new int[3];
   myArray[0] = 1;
   myArray[1] = 2;
   myArray[2] = 3;
   return myArray;
}

int main()
{
   int* result = myFunction();
   // 使用 result
   delete[] result;
   return 0;
}
```


## 字符串

C++ 提供了以下两种类型的字符串表示形式：

- C 风格字符串
- C++ 引入的 string 类类型



### C 风格字符串

字符串实际上是使用 **null** 字符 **\0** 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。

由于在数组的末尾存储了空字符，所以字符数组的大小比单词 **RUNOOB** 的字符数多一个。

```cpp
char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};
```

依据数组初始化规则，您可以把上面的语句写成以下语句：

```cpp
char site[] = "RUNOOB";
```

![C/C++ 中的字符串表示](https://www.runoob.com/wp-content/uploads/2014/09/c-strings-2020-12-21.png)

C++ 中有大量的函数用来操作以 null 结尾的字符串:

| 序号 | 函数 & 目的                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |
| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 **+** 号，例如: `string str1 = "runoob"; string str2 = "google"; string str = str1 + str2;` |
| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。 |
| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |
| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |



### C++ 中的 String 类

C++ 标准库提供了 **string** 类类型，支持上述所有的操作，另外还增加了其他更多的功能。

```cpp
#include <iostream>
#include <string>
 
using namespace std;
 
int main ()
{
   string str1 = "runoob";
   string str2 = "google";
   string str3;
   int  len ;
 
   // 复制 str1 到 str3
   str3 = str1;
   cout << "str3 : " << str3 << endl;
 
   // 连接 str1 和 str2
   str3 = str1 + str2;
   cout << "str1 + str2 : " << str3 << endl;
 
   // 连接后，str3 的总长度
   len = str3.size();
   cout << "str3.size() :  " << len << endl;
 
   return 0;
}
```



## 指针

每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。

**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。

用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：

```cpp
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
```

所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

### 使用指针

使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 `*` 来返回位于操作数所指定地址的变量的值。

```cpp
#include <iostream>
using namespace std;

int main() {
    int var = 20;
    int *ip;
    ip = &var;
    
    cout << "var的值: " << var << endl;
    cout << "var的地址 (&var): " << &var << endl;
    cout << "ip存储的地址: " << ip << endl;
    cout << "ip自身的地址 (&ip): " << &ip << endl;
    cout << "通过ip访问的值 (*ip): " << *ip << endl;

    var = 30;
    cout << "var的值: " << var << endl;
    cout << "var的地址 (&var): " << &var << endl;
    cout << "ip存储的地址: " << ip << endl;
    cout << "ip自身的地址 (&ip): " << &ip << endl;
    cout << "通过ip访问的值 (*ip): " << *ip << endl;

    int var2 = 40;
    ip = &var2;
    
    cout << "var2的值: " << var2 << endl;
    cout << "var2的地址 (&var2): " << &var2 << endl;
    cout << "ip存储的地址: " << ip << endl;
    cout << "ip自身的地址 (&ip): " << &ip << endl;
    cout << "通过ip访问的值 (*ip): " << *ip << endl;

    return 0;
}
```

```cpp
var的值: 20
var的地址 (&var): 0x7fffffffd898
ip存储的地址: 0x7fffffffd898
ip自身的地址 (&ip): 0x7fffffffd8a0
通过ip访问的值 (*ip): 20
var的值: 30
var的地址 (&var): 0x7fffffffd898
ip存储的地址: 0x7fffffffd898
ip自身的地址 (&ip): 0x7fffffffd8a0
通过ip访问的值 (*ip): 30
var2的值: 40
var2的地址 (&var2): 0x7fffffffd89c
ip存储的地址: 0x7fffffffd89c
ip自身的地址 (&ip): 0x7fffffffd8a0
通过ip访问的值 (*ip): 40
```

### Null 指针

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的**编程习惯**。赋为 NULL 值的指针被称为空指针。

NULL 指针是一个定义在标准库中的值为零的常量。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

### 指针的算术运算

可以对指针进行四种算术运算：`++`、`--`、`+`、`-`。

假设 ptr 是一个指向地址 1000 的**整型指针**，是一个 32 位的整数，让我们对该指针执行下列的算术运算：
```cpp
ptr++
```
执行 ptr++ 后，指针 ptr 会向前移动 4 个字节，指向下一个整型元素的地址。这是由于指针算术运算会根据指针的类型和大小来决定移动的距离。在这种情况下，由于是一个 32 位整数指针，每个整数占据 4 个字节，因此 ptr++ 会将指针 ptr 向前移动 4 个字节，指向下一个整型元素的地址。

指针算术运算的详细解析：

- 加法运算：可以对指针进行加法运算。当一个指针p加上一个整数n时，结果是指针p向前移动n个元素的大小。例如，如果p是一个int类型的指针，每个int占4个字节，那么`p + 1`将指向p所指向的下一个int元素。

- 减法运算：可以对指针进行减法运算。当一个指针p减去一个整数n时，结果是指针p向后移动n个元素的大小。例如，如果p是一个int类型的指针，每个int占4个字节，那么`p - 1`将指向p所指向的前一个int元素。

- 指针与指针之间的减法运算：可以计算两个指针之间的距离。当从一个指针p减去另一个指针q时，结果是两个指针之间的元素个数。例如，如果p和q是两个int类型的指针，每个int占4个字节，那么`p - q`将得到两个指针之间的元素个数。

- 指针与整数之间的比较运算：可以将指针与整数进行比较运算。可以使用关系运算符（如<、>、<=、>=）对指针和整数进行比较。这种比较通常用于判断指针是否指向某个有效的内存位置。

#### 指针与整数之间的比较运算

检查指针是否在数组有效范围内
```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int *p = arr;  // 指向数组开头
    
    // 遍历数组，确保指针不越界
    for (int i = 0; i < 5; i++) {
        // 检查指针是否还在数组范围内
        if (p < arr + 5) {  // 指针与整数表达式比较
            cout << *p << " ";
            p++;
        }
    }
    cout << endl;
    
    // 检查指针是否越界
    if (p >= arr + 5) {
        cout << "指针已到达数组末尾" << endl;
    }
    
    return 0;
}
```

检查空指针和有效地址
```cpp
#include <iostream>
using namespace std;

int main() {
    int *ptr = nullptr;
    int value = 100;
    
    // 检查指针是否为null（与0比较）
    if (ptr == 0) {
        cout << "指针为空" << endl;
    }
    
    ptr = &value;
    
    // 检查指针是否非空
    if (ptr != 0) {
        cout << "指针指向有效地址: " << *ptr << endl;
    }
    
    // 检查指针是否指向特定内存区域（嵌入式系统中常见）
    if ((unsigned long)ptr < 0x100000) {
        cout << "指针指向低端内存" << endl;
    }
    
    return 0;
}
```

内存块边界检查
```cpp
#include <iostream>
using namespace std;

int main() {
    const int BUFFER_SIZE = 100;
    char buffer[BUFFER_SIZE];
    char *current = buffer;
    
    // 模拟向缓冲区写入数据
    for (int i = 0; i < 10; i++) {
        // 检查指针是否还在缓冲区范围内
        if (current < buffer + BUFFER_SIZE) {
            *current = 'A' + i;
            current++;
        } else {
            cout << "缓冲区已满！" << endl;
            break;
        }
    }
    
    // 重置指针并读取
    current = buffer;
    while (current < buffer + 10) {  // 指针与整数表达式比较
        cout << *current << " ";
        current++;
    }
    cout << endl;
    
    return 0;
}
```

动态内存管理中的边界检查
```cpp
#include <iostream>
using namespace std;

int main() {
    int *dynamicArray = new int[10];
    int *start = dynamicArray;
    int *end = dynamicArray + 10;
    int *p = dynamicArray;
    
    // 安全地遍历动态数组
    for (int i = 0; i < 15; i++) {  // 故意超过边界
        if (p < end) {  // 重要：检查指针是否越界
            *p = i * 10;
            p++;
        } else {
            cout << "警告：试图访问超出分配的内存！" << endl;
            break;
        }
    }
    
    // 显示结果
    p = start;
    while (p < end) {
        cout << *p << " ";
        p++;
    }
    cout << endl;
    
    delete[] dynamicArray;
    return 0;
}
```

嵌入式系统中的硬件寄存器访问
```cpp
// 在嵌入式系统中，经常需要检查指针是否指向特定的硬件寄存器地址
#include <iostream>
using namespace std;

int main() {
    // 假设这些是硬件寄存器的地址
    const unsigned long UART_BASE = 0x40000000;
    const unsigned long GPIO_BASE = 0x40020000;
    
    volatile unsigned int *uartPtr = (volatile unsigned int*)UART_BASE;
    volatile unsigned int *gpioPtr = (volatile unsigned int*)GPIO_BASE;
    
    // 检查指针是否指向预期的硬件地址范围
    if ((unsigned long)uartPtr >= 0x40000000 && (unsigned long)uartPtr < 0x40010000) {
        cout << "UART指针在预期范围内" << endl;
    }
    
    if ((unsigned long)gpioPtr >= 0x40020000 && (unsigned long)gpioPtr < 0x40030000) {
        cout << "GPIO指针在预期范围内" << endl;
    }
    
    return 0;
}
```

重要注意事项：
- 类型安全：比较前确保类型正确，可能需要类型转换

- 有效性：这种比较只能检查相对位置，不能保证指针绝对有效

- 可移植性：直接与硬编码地址比较会降低代码可移植性

- 现代C++：在现代C++中，更推荐使用标准库容器和迭代器来避免这类底层指针操作


### 指针 vs 数组

指针和数组并不是完全互换的。
```cpp
#include <iostream>
 
using namespace std;
const int MAX = 3;
 
int main ()
{
   int  var[MAX] = {10, 100, 200};
 
   for (int i = 0; i < MAX; i++)
   {
      *var = i;    // 这是正确的语法
      var++;       // 这是不正确的
   }
   return 0;
}
```
把指针运算符 `*` 应用到 var 上是完全可以的，但修改 var 的值是非法的。这是因为 var 是一个指向数组开头的常量，不能作为左值。

### 指针数组

我们想要让数组存储指向 int 或 char 或其他数据类型的指针。下面是一个指向整数的指针数组的声明：`int *ptr[MAX];`

在这里，把 ptr 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。

可以用一个指向字符的指针数组来存储一个字符串列表:
```cpp
#include <iostream>
 
using namespace std;
const int MAX = 4;
 
int main ()
{
 const char *names[MAX] = {
                   "Zara Ali",
                   "Hina Ali",
                   "Nuha Ali",
                   "Sara Ali",
   };
 
   for (int i = 0; i < MAX; i++)
   {
      cout << "Value of names[" << i << "] = ";
      cout << names[i] << endl;
   }
   return 0;
}
```
```cpp
Value of names[0] = Zara Ali
Value of names[1] = Hina Ali
Value of names[2] = Nuha Ali
Value of names[3] = Sara Ali
```

### 指向指针的指针（多级间接寻址）

指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。

指针的指针就是将指针的地址存放在另一个指针里面。

通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

<img width="414" height="65" alt="image" src="https://github.com/user-attachments/assets/f6fe17aa-18db-49b3-ace8-1b1c3955e8ee" />

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号，例如：`int **var;`

当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符
```cpp
#include <iostream>
 
using namespace std;
 
int main ()
{
    int  var;
    int  *ptr;
    int  **pptr;
 
    var = 3000;
 
    // 获取 var 的地址
    ptr = &var;
 
    // 使用运算符 & 获取 ptr 的地址
    pptr = &ptr;
 
    // 使用 pptr 获取值
    cout << "var 值为 :" << var << endl;
    cout << "*ptr 值为:" << *ptr << endl;
    cout << "**pptr 值为:" << **pptr << endl;
 
    return 0;
}
```
结果：
```cpp
var 值为 :3000
*ptr 值为:3000
**pptr 值为:3000
```

### 传递指针给函数
C++ 允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。

传递一个无符号的 long 型指针给函数，并在函数内改变这个值：
```cpp
#include <iostream>
#include <ctime>
 
using namespace std;
 
// 在写函数时应习惯性的先声明函数，然后在定义函数
void getSeconds(unsigned long *par);
 
int main ()
{
   unsigned long sec;
 
 
   getSeconds( &sec );
 
   // 输出实际值
   cout << "Number of seconds :" << sec << endl;
 
   return 0;
}
 
void getSeconds(unsigned long *par)
{
   // 获取当前的秒数
   *par = time( NULL );
   return;
}
```
结果：
```cpp
Number of seconds :1294450468
```

### 从函数返回指针
C++ 允许您从函数返回指针。为了做到这点，您必须声明一个返回指针的函数，如下所示：
```cpp
int * myFunction()
{
.
.
.
}
```
另外，C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static变量。




## 引用

引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。

一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

**引用必须在定义时初始化**，并且**一旦绑定到一个变量后，就不能再绑定到其他变量**。

引用的语法如下：

```
int a = 10;
int &ref = a;  // ref 是 a 的引用
```

- `int &ref` 表示 `ref` 是一个 `int` 类型的引用。
- `ref` 是 `a` 的别名，对 `ref` 的操作会直接作用于 `a`。



### 引用 vs 指针

引用很容易与指针混淆，它们之间有三个主要的不同：

- 不存在空引用，引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。
- 引用的对象必须是一个变量，而指针必须是一个地址。

| **特性**                | **引用**                                                     | **指针**                                                     |
| :---------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **定义与初始化**        | 必须初始化，且不能为 `null`。                                | 可以不初始化，可以在后续代码中指向其他对象，可以为 `null`。  |
| **语法**                | 使用 `&` 声明，例如：`int &ref = a;`                         | 使用 `*` 声明，例如：`int *ptr = &a;`                        |
| **重新绑定**            | 不能重新绑定，一旦初始化后始终引用同一个对象。               | 可以重新指向其他对象，例如：`ptr = &b;`                      |
| **空值（Nullability）** | 不能为 `null`，必须绑定到有效的对象。                        | 可以为 `null`，表示不指向任何对象。                          |
| **内存占用**            | 不占用额外内存（编译器通常将其优化为直接操作所引用的对象）。 | 占用额外内存（存储地址，通常是一个机器字长，如4字节或8字节）。 |
| **访问方式**            | 直接使用，无需解引用操作符，例如：`ref = 10;`                | 需要使用 `*` 解引用操作符访问或修改所指向的对象，例如：`*ptr = 10;` |
| **多级间接访问**        | 不支持多级间接访问（不能有引用的引用）。                     | 支持多级间接访问（如指针的指针：`int **pptr;`）。            |
| **函数参数传递**        | 常用于函数参数传递，语法简洁，例如：`void func(int &x) { x = 10; }` | 也可以用于函数参数传递，但需要使用解引用操作符，例如：`void func(int *x) { *x = 10; }` |
| **数组与引用**          | 不能直接创建引用数组，但可以创建数组的引用，例如：`int (&ref)[10] = arr;` | 可以创建指针数组，也可以创建指向数组的指针，例如：`int *ptrArr[10];` |
| **安全性**              | 更安全，不能为 `null`，且语法更直观。                        | 更灵活，但容易出错（如空指针、野指针等）。                   |
| **底层实现**            | 通常通过指针实现，但编译器会优化为直接操作所引用的对象。     | 直接存储目标对象的内存地址。                                 |

### 把引用作为参数

使用了引用来实现引用调用函数。
```cpp
#include <iostream>
using namespace std;
 
// 函数声明
void swap(int& x, int& y);
 
int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
 
   cout << "交换前，a 的值：" << a << endl;
   cout << "交换前，b 的值：" << b << endl;
 
   /* 调用函数来交换值 */
   swap(a, b);
 
   cout << "交换后，a 的值：" << a << endl;
   cout << "交换后，b 的值：" << b << endl;
 
   return 0;
}
 
// 函数定义
void swap(int& x, int& y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */
  
   return;
}
```



### 把引用作为返回值
通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。

当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。
```cpp
#include <iostream>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues(int i) {  
   double& ref = vals[i];    
   return ref;   // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]
 
 
}
 
// 要调用上面定义函数的主函数
int main ()
{
 
   cout << "改变前的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
 
   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素
 
   cout << "改变后的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   return 0;
}
```
结果：
```cpp
改变前的值
vals[0] = 10.1
vals[1] = 12.6
vals[2] = 33.1
vals[3] = 24.1
vals[4] = 50
改变后的值
vals[0] = 10.1
vals[1] = 20.23
vals[2] = 33.1
vals[3] = 70.8
vals[4] = 50

```
当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。
```cpp
int& func() {
   int q;
   //! return q; // 在编译时发生错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
```
静态变量的引用：
```cpp
#include <iostream>
using namespace std;

// 返回对静态变量的引用
int& getStaticRef() {
    static int num = 5; // 静态变量
    return num;
}

int main() {
    int& ref = getStaticRef(); // 获取对静态变量的引用
    cout << "初始值：" << ref << endl;

    ref = 10; // 修改静态变量的值

    cout << "修改后的值：" << ref << endl;
    cout << "再次调用函数后的值：" << getStaticRef() << endl;

    return 0;
}
```
getStaticRef() 函数返回了对静态变量 num 的引用。

输出结果为：
```cpp
初始值：5
修改后的值：10
再次调用函数后的值：10
```

## 基本输入输出
C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。

### I/O 库头文件

| 头文件       | 函数和描述                                                   |
| ------------ | ------------------------------------------------------------ |
| `<iostream>` | 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 |
| `<iomanip>`  | 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 |
| `<fstream>`  | 该文件为用户控制的文件处理声明服务。 |

### 标准错误流（cerr）

预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。

cerr 也是与流插入运算符 << 结合使用的，如下所示：
```cpp
#include <iostream>
 
using namespace std;
 
int main( )
{
   char str[] = "Unable to read....";
 
   cerr << "Error message : " << str << endl;
}
```

### 标准日志流（clog）

<img width="680" height="252" alt="image" src="https://github.com/user-attachments/assets/6be69ed4-fdab-4976-8af8-7d10a0c97676" />
预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。

clog 也是与流插入运算符 << 结合使用的，如下所示：
```cpp
#include <iostream>
 
using namespace std;
 
int main( )
{
   char str[] = "Unable to read....";
 
   clog << "Error message : " << str << endl;
}
```


## 结构体（struct）

在 C++ 中，struct 语句用于定义结构体（structure）。

结构体是一种用户自定义的数据类型，用于将不同类型的数据组合在一起。与类（class）类似，结构体允许你定义成员变量和成员函数。

为了定义结构，您必须使用 **struct** 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：

```cpp
struct type_name {
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
} object_names;
```

**type_name** 是结构体类型的名称，**member_type1 member_name1** 是标准的变量定义，比如 **int i;** 或者 **float f;** 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 **Books**，变量为 **book**：

```cpp
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;
```

结构体优点：

- 简单数据封装：适合封装多种类型的简单数据，通常用于数据的存储。
- 轻量级：相比 class，结构体语法更简洁，适合小型数据对象。
- 面向对象支持：支持构造函数、成员函数和访问权限控制，可以实现面向对象的设计。

为了访问结构的成员，我们使用**成员访问运算符（.）**。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。

```cpp
#include <iostream>
#include <cstring>
 
using namespace std;
 
// 声明一个结构体类型 Books 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   Books Book1;        // 定义结构体类型 Books 的变量 Book1
   Books Book2;        // 定义结构体类型 Books 的变量 Book2
 
   // Book1 详述
   strcpy( Book1.title, "C++ 教程");
   strcpy( Book1.author, "Runoob"); 
   strcpy( Book1.subject, "编程语言");
   Book1.book_id = 12345;
 
   // Book2 详述
   strcpy( Book2.title, "CSS 教程");
   strcpy( Book2.author, "Runoob");
   strcpy( Book2.subject, "前端技术");
   Book2.book_id = 12346;
 
   // 输出 Book1 信息
   cout << "第一本书标题 : " << Book1.title <<endl;
   cout << "第一本书作者 : " << Book1.author <<endl;
   cout << "第一本书类目 : " << Book1.subject <<endl;
   cout << "第一本书 ID : " << Book1.book_id <<endl;
 
   // 输出 Book2 信息
   cout << "第二本书标题 : " << Book2.title <<endl;
   cout << "第二本书作者 : " << Book2.author <<endl;
   cout << "第二本书类目 : " << Book2.subject <<endl;
   cout << "第二本书 ID : " << Book2.book_id <<endl;
 
   return 0;
}
```

您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。

```cpp
#include <iostream>
#include <cstring>
 
using namespace std;
void printBook( struct Books book );
 
// 声明一个结构体类型 Books 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   Books Book1;        // 定义结构体类型 Books 的变量 Book1
   Books Book2;        // 定义结构体类型 Books 的变量 Book2
 
    // Book1 详述
   strcpy( Book1.title, "C++ 教程");
   strcpy( Book1.author, "Runoob"); 
   strcpy( Book1.subject, "编程语言");
   Book1.book_id = 12345;
 
   // Book2 详述
   strcpy( Book2.title, "CSS 教程");
   strcpy( Book2.author, "Runoob");
   strcpy( Book2.subject, "前端技术");
   Book2.book_id = 12346;
 
   // 输出 Book1 信息
   printBook( Book1 );
 
   // 输出 Book2 信息
   printBook( Book2 );
 
   return 0;
}
void printBook( struct Books book )
{
   cout << "书标题 : " << book.title <<endl;
   cout << "书作者 : " << book.author <<endl;
   cout << "书类目 : " << book.subject <<endl;
   cout << "书 ID : " << book.book_id <<endl;
}
```

### 结构体的各个部分详细介绍

- **struct 关键字：**用于定义结构体，它告诉编译器后面要定义的是一个自定义类型。
- **成员变量：**成员变量是结构体中定义的数据项，它们可以是任何基本类型或其他自定义类型。在 struct 中，这些成员默认是 public，可以直接访问。
- **成员函数：**结构体中也可以包含成员函数，这使得结构体在功能上类似于类。成员函数可以操作结构体的成员变量，提供对数据的封装和操作。
- **访问权限：**与 class 类似，你可以在 struct 中使用 public、private 和 protected 来定义成员的访问权限。**在 struct 中，默认所有成员都是 public，而 class 中默认是 private。**

### 指向结构的指针

您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似:

```cpp
struct Books *struct_pointer;
```

可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 **&** 运算符放在结构名称的前面:

```cpp
struct_pointer = &Book1;
```

为了使用指向该结构的指针访问结构的成员，您必须使用 `->` 运算符:

```cpp
struct_pointer->title;
```

```cpp
#include <iostream>
#include <string>
 
using namespace std;
 
// 声明一个结构体类型 Books 
struct Books
{
    string title;
    string author;
    string subject;
    int book_id;
 
    // 构造函数
    Books(string t, string a, string s, int id)
        : title(t), author(a), subject(s), book_id(id) {}
};
 
// 打印书籍信息的函数，接受一个指向 Books 结构体的指针
void printBookInfo(const Books* book) {
    cout << "书籍标题: " << book->title << endl;
    cout << "书籍作者: " << book->author << endl;
    cout << "书籍类目: " << book->subject << endl;
    cout << "书籍 ID: " << book->book_id << endl;
}
 
int main()
{
    // 创建两本书的对象
    Books Book1("C++ 教程", "Runoob", "编程语言", 12345);
    Books Book2("CSS 教程", "Runoob", "前端技术", 12346);
 
    // 使用指针指向这两本书的对象
    Books* ptrBook1 = &Book1;
    Books* ptrBook2 = &Book2;
 
    // 输出书籍信息，传递指针
    printBookInfo(ptrBook1);
    printBookInfo(ptrBook2);
 
    return 0;
}
```

### `->` 和 `.` 运算符的区别
这两个运算符都用于访问结构体或类的成员，但使用场景不同：
`.` 运算符（成员访问运算符）
```cpp
struct Student {
    string name;
    int age;
};

int main() {
    Student s1;           // s1 是结构体变量
    s1.name = "Alice";    // 使用 . 访问成员
    s1.age = 20;
    
    return 0;
}
```
`->` 运算符（指针成员访问运算符）
```cpp
struct Student {
    string name;
    int age;
};

int main() {
    Student s1;
    Student *ptr = &s1;   // ptr 是指向结构体的指针
    
    ptr->name = "Bob";    // 使用 -> 通过指针访问成员
    ptr->age = 22;
    
    return 0;
}
```

`->` 实际上是 `*` 和 `.` 的组合简写：
```cpp
// 以下三行代码完全等价：
ptr->name = "Charlie";
(*ptr).name = "Charlie";  // 先解引用，再用点运算符
ptr[0].name = "Charlie";  // 数组表示法
```

<img width="590" height="476" alt="image" src="https://github.com/user-attachments/assets/4440f564-5e83-435a-95eb-fa312e711e61" />


### typedef 关键字

为创建的类型取一个"别名":

```cpp
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
}Books;
```

直接使用 *Books* 来定义 *Books* 类型的变量，而不需要使用 struct 关键字。

```cpp
Books Book1, Book2;
```

可以使用 **typedef** 关键字来定义非结构类型:

```cpp
typedef long int *pint32;
 
pint32 x, y, z;
```

### 结构体与类的区别

在 C++ 中，struct 和 class 本质上非常相似，唯一的区别在于默认的访问权限：

- `struct` 默认的成员和继承是 `public`。
- `class` 默认的成员和继承是 `private`。

你可以将 `struct` 当作一种简化形式的 `class`，适合用于没有太多复杂功能的简单数据封装。




## vector 容器

C++ 中的 vector 是一种序列容器，它允许你在运行时动态地插入和删除元素。

vector 是基于数组的数据结构，但它可以自动管理内存，这意味着你不需要手动分配和释放内存。

与 C++ 数组相比，vector 具有更多的灵活性和功能，使其成为 C++ 中常用的数据结构之一。

vector 是 C++ 标准模板库（STL）的一部分，提供了灵活的接口和高效的操作。

**基本特性:**

- **动态大小**：`vector` 的大小可以根据需要自动增长和缩小。
- **连续存储**：`vector` 中的元素在内存中是连续存储的，这使得访问元素非常快速。
- **可迭代**：`vector` 可以被迭代，你可以使用循环（如 `for` 循环）来访问它的元素。
- **元素类型**：`vector` 可以存储任何类型的元素，包括内置类型、对象、指针等。

**使用场景：**

- 当你需要一个可以动态增长和缩小的数组时。
- 当你需要频繁地在序列的末尾添加或移除元素时。
- 当你需要一个可以高效随机访问元素的容器时。

### 创建vector

导入头文件

```cpp
#include <vector>
```

```cpp
std::vector<int> myVector; // 创建一个存储整数的空 vector
```

在创建时指定初始大小和初始值：

```cpp
std::vector<int> myVector(5); // 创建一个包含 5 个整数的 vector，每个值都为默认值（0）
std::vector<int> myVector(5, 10); // 创建一个包含 5 个整数的 vector，每个值都为 10
```

或：

```cpp
std::vector<int> vec; // 默认初始化一个空的 vector
std::vector<int> vec2 = {1, 2, 3, 4}; // 初始化一个包含元素的 vector
```

### 添加元素

可以使用 push_back 方法向 vector 中添加元素：

```cpp
myVector.push_back(7); // 将整数 7 添加到 vector 的末尾
```

### 访问元素

可以使用下标操作符 [] 或 at() 方法访问 vector 中的元素：

```cpp
int x = myVector[0]; // 获取第一个元素
int y = myVector.at(1); // 获取第二个元素
```

### 获取大小

可以使用 size() 方法获取 vector 中元素的数量：

```cpp
int size = myVector.size(); // 获取 vector 中的元素数量
```

### 迭代访问

可以使用迭代器遍历 vector 中的元素：

```cpp
for (auto it = myVector.begin(); it != myVector.end(); ++it) {
    std::cout << *it << " ";
}
```

或者使用范围循环：

```cpp
for (int element : myVector) {
    std::cout << element << " ";
}
```

### 删除元素

可以使用 erase() 方法删除 vector 中的元素：

```cpp
myVector.erase(myVector.begin() + 2); // 删除第三个元素
```

### 清空 Vector

可以使用 clear() 方法清空 vector 中的所有元素：

```cpp
myVector.clear(); // 清空 vector
```

### 实例

```cpp
#include <iostream>
#include <vector>

int main() {
    // 创建一个空的整数向量
    std::vector<int> myVector;

    // 添加元素到向量中
    myVector.push_back(3);
    myVector.push_back(7);
    myVector.push_back(11);
    myVector.push_back(5);

    // 访问向量中的元素并输出
    std::cout << "Elements in the vector: ";
    for (int element : myVector) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    // 访问向量中的第一个元素并输出
    std::cout << "First element: " << myVector[0] << std::endl;

    // 访问向量中的第二个元素并输出
    std::cout << "Second element: " << myVector.at(1) << std::endl;

    // 获取向量的大小并输出
    std::cout << "Size of the vector: " << myVector.size() << std::endl;

    // 删除向量中的第三个元素
    myVector.erase(myVector.begin() + 2);

    // 输出删除元素后的向量
    std::cout << "Elements in the vector after erasing: ";
    for (int element : myVector) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    // 清空向量并输出
    myVector.clear();
    std::cout << "Size of the vector after clearing: " << myVector.size() << std::endl;

    return 0;
}
```

## 数据结构

常用的数据结构及其特点和用法:

### 1. **数组（Array）**

数组是最基础的数据结构，用于存储一组相同类型的数据。

**特点**：

- 固定大小，一旦声明，大小不能改变。
- 直接访问元素，时间复杂度为 O(1)。
- 适合处理大小已知、元素类型相同的集合。

#### 实例
```
int arr[5] = {1, 2, 3, 4, 5};
cout << arr[0]; // 输出第一个元素
```
**优缺点**：

- 优点：访问速度快，内存紧凑。
- 缺点：大小固定，无法动态扩展，不适合处理大小不确定的数据集。

### 2. **结构体（Struct）**

结构体允许将不同类型的数据组合在一起，形成一种自定义的数据类型。

**特点**：

- 可以包含不同类型的成员变量。
- 提供了对数据的基本封装，但功能有限。

**示例**：

#### 实例
```
struct Person {
  string name;
  int age;
};
Person p = {"Alice", 25};
cout << p.name << endl; // 输出 Alice
```
### 3. **类（Class）**

类是 C++ 中用于面向对象编程的核心结构，允许定义成员变量和成员函数。与 `struct` 类似，但功能更强大，支持继承、封装、多态等特性。

**特点**：

- 可以包含成员变量、成员函数、构造函数、析构函数。
- 支持面向对象特性，如封装、继承、多态。

#### 实例
```
class Person {
private:
  string name;
  int age;
public:
  Person(string n, int a) : name(n), age(a) {}
  void printInfo() {
    cout << "Name: " << name << ", Age: " << age << endl;
  }
};
Person p("Bob", 30);
p.printInfo(); // 输出: Name: Bob, Age: 30
```
### 4. **链表（Linked List）**

链表是一种动态数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。

**特点**：

- 动态调整大小，不需要提前定义容量。
- 插入和删除操作效率高，时间复杂度为 O(1)（在链表头部或尾部操作）。
- 线性查找，时间复杂度为 O(n)。

#### 实例（单向链表）
```
struct Node {
  int data;
  Node* next;
};
Node* head = nullptr;
Node* newNode = new Node{10, nullptr};
head = newNode; // 插入新节点
```
**优缺点**：

- 优点：动态大小，适合频繁插入和删除的场景。
- 缺点：随机访问效率低，不如数组直接访问快。

### 5. **栈（Stack）**

栈是一种后进先出（LIFO, Last In First Out）的数据结构，常用于递归、深度优先搜索等场景。

**特点**：

- 只允许在栈顶进行插入和删除操作。
- 时间复杂度为 O(1)。

#### 实例
```
stack<int> s;
s.push(1);
s.push(2);
cout << s.top(); // 输出 2
s.pop();
```
**优缺点**：

- 优点：操作简单，效率高。
- 缺点：只能在栈顶操作，访问其他元素需要弹出栈顶元素。

### 6. **队列（Queue）**

队列是一种先进先出（FIFO, First In First Out）的数据结构，常用于广度优先搜索、任务调度等场景。

**特点**：

- 插入操作在队尾进行，删除操作在队头进行。
- 时间复杂度为 O(1)。

#### 实例
```
queue<int> q;
q.push(1);
q.push(2);
cout << q.front(); // 输出 1
q.pop();
```
**优缺点**：

- 优点：适合按顺序处理数据的场景，如任务调度。
- 缺点：无法随机访问元素。

### 7. **双端队列（Deque）**

双端队列允许在两端进行插入和删除操作，是栈和队列的结合体。

**特点**：

- 允许在两端进行插入和删除。
- 时间复杂度为 O(1)。

#### 实例
```
deque<int> dq;
dq.push_back(1);
dq.push_front(2);
cout << dq.front(); // 输出 2
dq.pop_front();
```
**优缺点**：

- 优点：灵活的双向操作。
- 缺点：空间占用较大，适合需要在两端频繁操作的场景。

### 8. **哈希表（Hash Table）**

哈希表是一种通过键值对存储数据的数据结构，支持快速查找、插入和删除操作。C++ 中的 `unordered_map` 是哈希表的实现。

**特点**：

- 使用哈希函数快速定位元素，时间复杂度为 O(1)。
- 不保证元素的顺序。

#### 实例
```
unordered_map<string, int> hashTable;
hashTable["apple"] = 10;
cout << hashTable["apple"]; // 输出 10
```
**优缺点**：

- 优点：查找、插入、删除操作效率高。
- 缺点：无法保证元素顺序，哈希冲突时性能会下降。

### 9. **映射（Map）**

`map` 是一种有序的键值对容器，底层实现是红黑树。与 `unordered_map` 不同，它保证键的顺序，查找、插入和删除的时间复杂度为 O(log n)。

**特点**：

- 保证元素按键的顺序排列。
- 使用二叉搜索树实现。

#### 实例
```
map<string, int> myMap;
myMap["apple"] = 10;
cout << myMap["apple"]; // 输出 10
```
**优缺点**：

- 优点：元素有序，适合需要按顺序处理数据的场景。
- 缺点：操作效率比 `unordered_map` 略低。

### 10. **集合（Set）**

`set` 是一种用于存储唯一元素的有序集合，底层同样使用红黑树实现。它保证元素不重复且有序。

**特点**：

- 保证元素的唯一性。
- 元素自动按升序排列。
- 时间复杂度为 O(log n)。

#### 实例
```
set<int> s;
s.insert(1);
s.insert(2);
cout << *s.begin(); // 输出 1
```
**优缺点**：

- 优点：自动排序和唯一性保证。
- 缺点：插入和删除的效率不如无序集合。

### 11. **动态数组（Vector）**

`vector` 是 C++ 标准库提供的动态数组实现，可以动态扩展容量，支持随机访问。

**特点**：

- 动态调整大小。
- 支持随机访问，时间复杂度为 O(1)。
- 当容量不足时，动态扩展，时间复杂度为摊销 O(1)。

#### 实例
```
vector<int> v;
v.push_back(1);
v.push_back(2);
cout << v[0]; // 输出 1
```
**优缺点**：

- 优点：支持随机访问，动态扩展。
- 缺点：插入和删除中间元素的效率较低。

## 类 & 对象
定义一个类需要使用关键字 class，然后指定类的名称，并类的主体是包含在一对花括号中，主体包含类的成员变量和成员函数。

定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。
<img width="681" height="441" alt="image" src="https://github.com/user-attachments/assets/c5340562-1930-4315-869d-859fc050fddc" />

类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。

类的对象的公共数据成员可以使用直接成员访问运算符 `.` 来访问。
<img width="442" height="272" alt="image" src="https://github.com/user-attachments/assets/34e887ee-4fb0-4a03-8450-6e7c99dc8f44" />
需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (`.`) 来直接访问。

### 类成员函数
类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。

成员函数可以定义在类定义内部，或者单独使用范围解析运算符 `::` 来定义。在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。
```cpp
class Box
{
   public:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度
   
      double getVolume(void)
      {
         return length * breadth * height;
      }
};
// 或如下
double Box::getVolume(void)
{
    return length * breadth * height;
}
```

设置和获取类中不同的成员的值：
```cpp
#include <iostream>
 
using namespace std;
 
class Box
{
   public:
      double length;         // 长度
      double breadth;        // 宽度
      double height;         // 高度
 
      // 成员函数声明
      double getVolume(void);
      void setLength( double len );
      void setBreadth( double bre );
      void setHeight( double hei );
};
 
// 成员函数定义
double Box::getVolume(void)
{
    return length * breadth * height;
}
 
void Box::setLength( double len )
{
    length = len;
}
 
void Box::setBreadth( double bre )
{
    breadth = bre;
}
 
void Box::setHeight( double hei )
{
    height = hei;
}
 
// 程序的主函数
int main( )
{
   Box Box1;                // 声明 Box1，类型为 Box
   Box Box2;                // 声明 Box2，类型为 Box
   double volume = 0.0;     // 用于存储体积
 
   // box 1 详述
   Box1.setLength(6.0); 
   Box1.setBreadth(7.0); 
   Box1.setHeight(5.0);
 
   // box 2 详述
   Box2.setLength(12.0); 
   Box2.setBreadth(13.0); 
   Box2.setHeight(10.0);
 
   // box 1 的体积
   volume = Box1.getVolume();
   cout << "Box1 的体积：" << volume <<endl;
 
   // box 2 的体积
   volume = Box2.getVolume();
   cout << "Box2 的体积：" << volume <<endl;
   return 0;
}
```

### 类访问修饰符
数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 `public、private、protected` 来指定的。关键字 `public、private、protected` 称为访问修饰符。

一个类可以有多个 `public、protected` 或 `private` 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 `private`。

#### 公有（public）成员
公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值
```cpp
#include <iostream>
 
using namespace std;
 
class Line
{
   public:
      double length;
      void setLength( double len );
      double getLength( void );
};
 
// 成员函数定义
double Line::getLength(void)
{
    return length ;
}
 
void Line::setLength( double len )
{
    length = len;
}
 
// 程序的主函数
int main( )
{
   Line line;
 
   // 设置长度
   line.setLength(6.0); 
   cout << "Length of line : " << line.getLength() <<endl;
 
   // 不使用成员函数设置长度
   line.length = 10.0; // OK: 因为 length 是公有的
   cout << "Length of line : " << line.length <<endl;
   return 0;
}
```

#### 私有（private）成员
私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。

默认情况下，类的所有成员都是私有的。例如在下面的类中，width 是一个私有成员，这意味着，如果您没有使用任何访问修饰符，类的成员将被假定为私有成员

实际操作中，我们一般会在私有区域定义数据，在公有区域定义相关的函数，以便在类的外部也可以调用这些函数

#### protected（受保护）成员
protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。

#### 继承中的特点
有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。

1. public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private

2. protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private

3. private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private

但无论哪种继承方式，下面两点都没有改变：

1. private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；

2. protected 成员可以被派生类访问。

<img width="886" height="371" alt="image" src="https://github.com/user-attachments/assets/79c67d9b-5cf1-45ed-9aa2-002d8cc59db2" />

### 类构造函数 & 析构函数
#### 构造函数
类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。

构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。
```cpp
#include <iostream>
 
using namespace std;
 
class Line
{
   public:
      void setLength( double len );
      double getLength( void );
      Line();  // 这是构造函数
 
   private:
      double length;
};
 
// 成员函数定义，包括构造函数
Line::Line(void)
{
    cout << "Object is being created" << endl;
}
 
void Line::setLength( double len )
{
    length = len;
}
 
double Line::getLength( void )
{
    return length;
}
// 程序的主函数
int main( )
{
   Line line;
 
   // 设置长度
   line.setLength(6.0); 
   cout << "Length of line : " << line.getLength() <<endl;
 
   return 0;
}
```
默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值，如下面的例子所示：
```cpp
#include <iostream>
 
using namespace std;
 
class Line
{
   public:
      void setLength( double len );
      double getLength( void );
      Line(double len);  // 这是构造函数
 
   private:
      double length;
};
 
// 成员函数定义，包括构造函数
Line::Line( double len)
{
    cout << "Object is being created, length = " << len << endl;
    length = len;
}
 
void Line::setLength( double len )
{
    length = len;
}
 
double Line::getLength( void )
{
    return length;
}
// 程序的主函数
int main( )
{
   Line line(10.0);
 
   // 获取默认设置的长度
   cout << "Length of line : " << line.getLength() <<endl;
   // 再次设置长度
   line.setLength(6.0); 
   cout << "Length of line : " << line.getLength() <<endl;
 
   return 0;
}
```

使用初始化列表来初始化字段
```cpp
Line::Line( double len): length(len)
{
    cout << "Object is being created, length = " << len << endl;
}
```
上面的语法等同于如下语法：
```cpp
Line::Line( double len)
{
    length = len;
    cout << "Object is being created, length = " << len << endl;
}
```

#### 析构函数
类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。

析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。
```cpp
#include <iostream>
 
using namespace std;
 
class Line
{
   public:
      void setLength( double len );
      double getLength( void );
      Line();   // 这是构造函数声明
      ~Line();  // 这是析构函数声明
 
   private:
      double length;
};
 
// 成员函数定义，包括构造函数
Line::Line(void)
{
    cout << "Object is being created" << endl;
}
Line::~Line(void)
{
    cout << "Object is being deleted" << endl;
}
 
void Line::setLength( double len )
{
    length = len;
}
 
double Line::getLength( void )
{
    return length;
}
// 程序的主函数
int main( )
{
   Line line;
 
   // 设置长度
   line.setLength(6.0); 
   cout << "Length of line : " << line.getLength() <<endl;
 
   return 0;
}
```

### 拷贝构造函数
拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：

通过使用另一个同类型的对象来初始化新创建的对象。

复制对象把它作为参数传递给函数。

复制对象，并从函数返回这个对象。

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：在这里，obj 是一个对象引用，该对象是用于初始化另一个对象的。
```cpp
classname (const classname &obj) {
   // 构造函数的主体
}
```

通过使用已有的同类型的对象来初始化新创建的对象：
```cpp
#include <iostream>
 
using namespace std;
 
class Line
{
   public:
      int getLength( void );
      Line( int len );             // 简单的构造函数
      Line( const Line &obj);      // 拷贝构造函数
      ~Line();                     // 析构函数
 
   private:
      int *ptr;
};
 
// 成员函数定义，包括构造函数
Line::Line(int len)
{
    cout << "调用构造函数" << endl;
    // 为指针分配内存
    ptr = new int;
    *ptr = len;
}
 
Line::Line(const Line &obj)
{
    cout << "调用拷贝构造函数并为指针 ptr 分配内存" << endl;
    ptr = new int;
    *ptr = *obj.ptr; // 拷贝值
}
 
Line::~Line(void)
{
    cout << "释放内存" << endl;
    delete ptr;
}
int Line::getLength( void )
{
    return *ptr;
}
 
void display(Line obj)
{
   cout << "line 大小 : " << obj.getLength() <<endl;
}
 
// 程序的主函数
int main( )
{
   Line line1(10);
 
   Line line2 = line1; // 这里也调用了拷贝构造函数
 
   display(line1);
   display(line2);
 
   return 0;
}
```
结果：
```cpp
调用构造函数
调用拷贝构造函数并为指针 ptr 分配内存
调用拷贝构造函数并为指针 ptr 分配内存
line 大小 : 10
释放内存
调用拷贝构造函数并为指针 ptr 分配内存
line 大小 : 10
释放内存
释放内存
释放内存
```

### 友元函数
类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend
```cpp
#include <iostream>

using namespace std;

class Box
{
    double width;
public:
    friend void printWidth(Box box);
    friend class BigBox;
    void setWidth(double wid);
};

class BigBox
{
public :
    void Print(int width, Box &box)
    {
        // BigBox是Box的友元类，它可以直接访问Box类的任何成员
        box.setWidth(width);
        cout << "Width of box : " << box.width << endl;
    }
};

// 成员函数定义
void Box::setWidth(double wid)
{
    width = wid;
}

// 请注意：printWidth() 不是任何类的成员函数
void printWidth(Box box)
{
    /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
    cout << "Width of box : " << box.width << endl;
}

// 程序的主函数
int main()
{
    Box box;
    BigBox big;

    // 使用成员函数设置宽度
    box.setWidth(10.0);

    // 使用友元函数输出宽度
    printWidth(box);

    // 使用友元类中的方法设置宽度
    big.Print(20, box);

    getchar();
    return 0;
}
```

因为友元函数没有this指针，则参数要有三种情况： 

要访问非static成员时，需要对象做参数；

要访问static成员或全局变量时，则不需要对象做参数；

如果做参数的对象是全局对象，则不需要对象做参数.

可以直接调用友元函数，不需要通过对象或指针

实例代码：
```cpp
class INTEGER
{
    friend void Print(const INTEGER& obj);//声明友元函数
};

void Print(const INTEGER& obj）
{
    //函数体
}

void main()
{
    INTEGER obj;
    Print(obj);//直接调用
}
```

### 内联函数
C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。

引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：

1. 在内联函数内不允许使用循环语句和开关语句；
2. 内联函数的定义必须出现在内联函数第一次调用之前；
3. 类结构中所在的类说明内部定义的函数是内联函数。

Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.

定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.

优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.

缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。

结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!

另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).

有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.

### this 指针
在 C++ 中，this 指针是一个特殊的指针，它指向当前对象的实例。

在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。

this是一个隐藏的指针，可以在类的成员函数中使用，它可以用来指向调用对象。

当一个对象的成员函数被调用时，编译器会隐式地传递该对象的地址作为 this 指针。

友元函数没有 this 指针，因为友元不是类的成员，只有成员函数才有 this 指针。

```cpp
#include <iostream>
 
class MyClass {
private:
    int value;
 
public:
    void setValue(int value) {
        this->value = value;
    }
 
    void printValue() {
        std::cout << "Value: " << this->value << std::endl;
    }
};
 
int main() {
    MyClass obj;
    obj.setValue(42);
    obj.printValue();
 
    return 0;
}
```
解析：

- 以上实例中，我们定义了一个名为 `MyClass` 的类，它有一个私有成员变量 `value`。

- 类中的 `setValue()` 函数用于设置 `value`的值，而 `printValue()` 函数用于打印 `value` 的值。

- 在 `setValue()` 函数中，我们使用 `this` 指针来引用当前对象的成员变量 `value`，并将传入的值赋给它，这样可以明确地告诉编译器我们想要访问当前对象的成员变量，而不是函数参数或局部变量。

- 在 `printValue()` 函数中，我们同样使用 `this` 指针来引用当前对象的成员变量 `value`，并将其打印出来。

- 在 `main()` 函数中，我们创建了一个 `MyClass` 的对象 `obj`，然后使用 `setValue()` 函数设置 `value` 的值为 `42`，并通过 `printValue()` 函数打印出来。

- 通过使用 `this` 指针，我们可以在成员函数中访问当前对象的成员变量，即使它们与函数参数或局部变量同名，这样可以避免命名冲突，并确保我们访问的是正确的变量。

比较长方体的体积：
```cpp
#include <iostream>
 
using namespace std;
 
class Box
{
   public:
      // 构造函数定义
      Box(double l=2.0, double b=2.0, double h=2.0)
      {
         cout <<"调用构造函数。" << endl;
         length = l;
         breadth = b;
         height = h;
      }
      double Volume()
      {
         return length * breadth * height;
      }
      int compare(Box box)
      {
         return this->Volume() > box.Volume();
      }
   private:
      double length;     // 宽度
      double breadth;    // 长度
      double height;     // 高度
};
 
int main(void)
{
   Box Box1(3.3, 1.2, 1.5);    // 声明 box1
   Box Box2(8.5, 6.0, 2.0);    // 声明 box2
 
   if(Box1.compare(Box2))
   {
      cout << "Box2 的体积比 Box1 小" <<endl;
   }
   else
   {
      cout << "Box2 的体积大于或等于 Box1" <<endl;
   }
   return 0;
}
```
当我们调用成员函数时，实际上是替某个对象调用它。

成员函数通过一个名为 this 的额外隐式参数来访问调用它的那个对象，当我们调用一个成员函数时，用请求该函数的对象地址初始化 this。

实际上，任何自定义名为 this 的参数或变量的行为都是非法的。

### 指向类的指针
一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 ->，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。

在 C++ 中，指向类的指针指向一个类的对象，与普通的指针相似，指向类的指针可以用于访问对象的成员变量和成员函数。
```cpp
#include <iostream>

class MyClass {
public:
    int data;

    void display() {
        std::cout << "Data: " << data << std::endl;
    }
};

int main() {
    // 创建类对象
    MyClass obj;
    obj.data = 42;

    // 声明和初始化指向类的指针
    MyClass *ptr = &obj;

    // 通过指针访问成员变量
    std::cout << "Data via pointer: " << ptr->data << std::endl;

    // 通过指针调用成员函数
    ptr->display();

    return 0;
}
```
结果：
```cpp
Data via pointer: 42
Data: 42
```

指向类的指针还可以用于动态分配内存，创建类的对象：
```cpp
#include <iostream>

class MyClass {
public:
    int data;

    void display() {
        std::cout << "Data: " << data << std::endl;
    }
};

int main() {
    // 动态分配内存创建类对象
    MyClass *ptr = new MyClass;
    ptr->data = 42;

    // 通过指针调用成员函数
    ptr->display();

    // 释放动态分配的内存
    delete ptr;

    return 0;
}
```

指向类的指针还可以用于动态分配内存，创建类的对象：
```cpp
#include <iostream>

class MyClass {
public:
    int data;

    void display() {
        std::cout << "Data: " << data << std::endl;
    }
};

int main() {
    // 动态分配内存创建类对象
    MyClass *ptr = new MyClass;
    ptr->data = 42;

    // 通过指针调用成员函数
    ptr->display();

    // 释放动态分配的内存
    delete ptr;

    return 0;
}
```

指向类的指针可以作为函数参数传递：
```cpp
#include <iostream>

class MyClass {
public:
    int data;

    void display() {
        std::cout << "Data: " << data << std::endl;
    }
};

// 函数接受指向类的指针作为参数
void processObject(MyClass *ptr) {
    ptr->display();
}

int main() {
    MyClass obj;
    obj.data = 42;

    // 将指向类的指针传递给函数
    processObject(&obj);

    return 0;
}
```

### 类的静态成员
使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。
<img width="561" height="451" alt="image" src="https://github.com/user-attachments/assets/6089dffb-1a5a-4247-a20f-cf104898a936" />

静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 `::` 来重新声明静态变量从而对它进行初始化
```cpp
#include <iostream>
 
using namespace std;
 
class Box
{
   public:
      static int objectCount;
      // 构造函数定义
      Box(double l=2.0, double b=2.0, double h=2.0)
      {
         cout <<"Constructor called." << endl;
         length = l;
         breadth = b;
         height = h;
         // 每次创建对象时增加 1
         objectCount++;
      }
      double Volume()
      {
         return length * breadth * height;
      }
   private:
      double length;     // 长度
      double breadth;    // 宽度
      double height;     // 高度
};
 
// 初始化类 Box 的静态成员
int Box::objectCount = 0;
 
int main(void)
{
   Box Box1(3.3, 1.2, 1.5);    // 声明 box1
   Box Box2(8.5, 6.0, 2.0);    // 声明 box2
 
   // 输出对象的总数
   cout << "Total objects: " << Box::objectCount << endl;
 
   return 0;
}
```

如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 `::` 就可以访问。

静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。

静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。

> 静态成员函数与普通成员函数的区别：
> - 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。
> - 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。

```cpp
#include <iostream>
 
using namespace std;
 
class Box
{
   public:
      static int objectCount;
      // 构造函数定义
      Box(double l=2.0, double b=2.0, double h=2.0)
      {
         cout <<"Constructor called." << endl;
         length = l;
         breadth = b;
         height = h;
         // 每次创建对象时增加 1
         objectCount++;
      }
      double Volume()
      {
         return length * breadth * height;
      }
      static int getCount()
      {
         return objectCount;
      }
   private:
      double length;     // 长度
      double breadth;    // 宽度
      double height;     // 高度
};
 
// 初始化类 Box 的静态成员
int Box::objectCount = 0;
 
int main(void)
{
  
   // 在创建对象之前输出对象的总数
   cout << "Inital Stage Count: " << Box::getCount() << endl;
 
   Box Box1(3.3, 1.2, 1.5);    // 声明 box1
   Box Box2(8.5, 6.0, 2.0);    // 声明 box2
 
   // 在创建对象之后输出对象的总数
   cout << "Final Stage Count: " << Box::getCount() << endl;
 
   return 0;
}
```
结果：
```cpp
Inital Stage Count: 0
Constructor called.
Constructor called.
Final Stage Count: 2
```

## 继承
继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。

当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。

继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。
<img width="412" height="403" alt="image" src="https://github.com/user-attachments/assets/2258aeb3-dd16-4849-9371-ce6e760bba9d" />
代码实现如下：
```cpp
// 基类
class Animal {
    // eat() 函数
    // sleep() 函数
};


//派生类
class Dog : public Animal {
    // bark() 函数
};
```

一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。

`class 派生类名 : 访问修饰符 基类1, 访问修饰符 基类2, ... {
    // 类体
};`

定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：

`class derived-class: access-specifier base-class`

其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。我们几乎不使用 protected 或 private 继承，通常使用 public 继承。

```cpp
#include <iostream>
#include <string>

// 第一个基类
class Animal {
protected:
    std::string name;
public:
    Animal(const std::string& n) : name(n) {}
    void eat() {
        std::cout << name << " is eating." << std::endl;
    }
};

// 第二个基类
class Flyable {
protected:
    int flightHeight;
public:
    Flyable(int height) : flightHeight(height) {}
    void fly() {
        std::cout << "Flying at " << flightHeight << " meters." << std::endl;
    }
};

// 第三个基类
class Swimmable {
protected:
    int swimSpeed;
public:
    Swimmable(int speed) : swimSpeed(speed) {}
    void swim() {
        std::cout << "Swimming at " << swimSpeed << " km/h." << std::endl;
    }
};

// 多重继承：Duck同时继承Animal、Flyable和Swimmable
class Duck : public Animal, public Flyable, public Swimmable {
public:
    // 构造函数需要初始化所有基类
    Duck(const std::string& name, int flyHeight, int swimSpeed) 
        : Animal(name), Flyable(flyHeight), Swimmable(swimSpeed) {}
    
    void quack() {
        std::cout << name << " says: Quack!" << std::endl;
    }
};

int main() {
    Duck duck("Donald", 100, 5);
    
    duck.eat();    // 来自Animal
    duck.fly();    // 来自Flyable  
    duck.swim();   // 来自Swimmable
    duck.quack();  // Duck自己的方法
    
    return 0;
}
```

派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。
<img width="1012" height="214" alt="image" src="https://github.com/user-attachments/assets/ab548b04-edfc-4578-8cac-a89848956daa" />

派生类无法继承基类以下方法：
- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

虚继承（virtual inheritance） 和 组合（composition），都是 C++ 中用来解决多重继承复杂性的重要概念

### 虚继承
在多重继承中，如果两个基类都继承自同一个祖先类，而你的派生类又同时继承这两个基类，就会出现“菱形继承”结构：
```cpp
      A
     / \
    B   C
     \ /
      D
```

这时，类 D 会包含两份类 A 的成员（一份来自 B，一份来自 C）。当你调用 A 中的函数或访问成员时，编译器不知道该用哪一份，就会报错。

虚继承的本质是：让所有中间派生类共享同一个基类子对象。无论通过多少条路径继承，共同的基类 A 在最终派生类 D 中只存在一份。
```cpp
#include <iostream>

class A {
public:
    int x = 10;
    void show() { std::cout << "A::x = " << x << std::endl; }
};

// 使用 virtual 关键字进行虚继承
class B : virtual public A {};
class C : virtual public A {};

// D 继承 B 和 C
class D : public B, public C {};

int main() {
    D d;
    d.show();      // ✅ 正确！只有一个 A
    std::cout << d.x << std::endl; // ✅ 不会歧义
    return 0;
}
```

组合是一种“has-a”（有一个）的关系，而不是“is-a”（是一个）的关系。

- 继承（Inheritance）：Dog is a Animal（狗是一种动物）
- 组合（Composition）：Car has a Engine（汽车有一个引擎）

在组合中，一个类包含其他类的对象作为成员，而不是继承它们。

用组合重写：
```cpp
#include <iostream>
#include <string>

class Flyable {
    int height;
public:
    Flyable(int h) : height(h) {}
    void fly() { std::cout << "Flying at " << height << "m\n"; }
};

class Swimmable {
    int speed;
public:
    Swimmable(int s) : speed(s) {}
    void swim() { std::cout << "Swimming at " << speed << "km/h\n"; }
};

class Duck {
    std::string name;
    Flyable wings;      // Duck 有一个 Flyable
    Swimmable fins;     // Duck 有一个 Swimmable

public:
    Duck(const std::string& n, int h, int s) 
        : name(n), wings(h), fins(s) {}

    void eat() { std::cout << name << " is eating.\n"; }
    void fly() { wings.fly(); }     // 委托给 wings
    void swim() { fins.swim(); }    // 委托给 fins
};
```


## 重载运算符和重载函数
C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。

重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。

当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。

### 函数重载
在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。**不能**仅通过返回类型的不同来重载函数。

```cpp
#include <iostream>
using namespace std;
 
class printData
{
   public:
      void print(int i) {
        cout << "整数为: " << i << endl;
      }
 
      void print(double  f) {
        cout << "浮点数为: " << f << endl;
      }
 
      void print(char c[]) {
        cout << "字符串为: " << c << endl;
      }
};
 
int main(void)
{
   printData pd;
 
   // 输出整数
   pd.print(5);
   // 输出浮点数
   pd.print(500.263);
   // 输出字符串
   char c[] = "Hello C++";
   pd.print(c);
 
   return 0;
}
```

### 运算符重载
重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。

下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问:
```cpp
#include <iostream>
using namespace std;
 
class Box
{
   public:
 
      double getVolume(void)
      {
         return length * breadth * height;
      }
      void setLength( double len )
      {
          length = len;
      }
 
      void setBreadth( double bre )
      {
          breadth = bre;
      }
 
      void setHeight( double hei )
      {
          height = hei;
      }
      // 重载 + 运算符，用于把两个 Box 对象相加
      Box operator+(const Box& b)
      {
         Box box;
         box.length = this->length + b.length;
         box.breadth = this->breadth + b.breadth;
         box.height = this->height + b.height;
         return box;
      }
   private:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度
};
// 程序的主函数
int main( )
{
   Box Box1;                // 声明 Box1，类型为 Box
   Box Box2;                // 声明 Box2，类型为 Box
   Box Box3;                // 声明 Box3，类型为 Box
   double volume = 0.0;     // 把体积存储在该变量中
 
   // Box1 详述
   Box1.setLength(6.0); 
   Box1.setBreadth(7.0); 
   Box1.setHeight(5.0);
 
   // Box2 详述
   Box2.setLength(12.0); 
   Box2.setBreadth(13.0); 
   Box2.setHeight(10.0);
 
   // Box1 的体积
   volume = Box1.getVolume();
   cout << "Volume of Box1 : " << volume <<endl;
 
   // Box2 的体积
   volume = Box2.getVolume();
   cout << "Volume of Box2 : " << volume <<endl;
 
   // 把两个对象相加，得到 Box3
   Box3 = Box1 + Box2;
 
   // Box3 的体积
   volume = Box3.getVolume();
   cout << "Volume of Box3 : " << volume <<endl;
 
   return 0;
}
```

### 可重载运算符
| 类别           | 运算符                                                         |
| -------------- | -------------------------------------------------------------- |
| 双目算术运算符 | + (加), - (减), * (乘), / (除), % (取模)                       |
| 关系运算符     | == (等于), != (不等于), < (小于), > (大于), <= (小于等于), >= (大于等于) |
| 逻辑运算符     | \|\| (逻辑或), && (逻辑与), ! (逻辑非)                         |
| 单目运算符     | + (正), - (负), * (指针), & (取地址)                           |
| 自增自减运算符 | ++ (自增), -- (自减)                                         |
| 位运算符       | \| (按位或), & (按位与), ~ (按位取反), ^ (按位异或), << (左移), >> (右移) |
| 赋值运算符     | =, +=, -=, *=, /=, %=, &=, \|=, ^=, <<=, >>=                    |
| 空间申请与释放 | new, delete, new[], delete[]                                   |
| 其他运算符     | () (函数调用), -> (成员访问), , (逗号), [] (下标)             |

### 不可重载运算符
- `.`：成员访问运算符
- `.*`， `->*`：成员指针访问运算符
- `::`：域运算符
- `sizeof`：长度运算符
- `?:`：条件运算符
- `#`： 预处理符号

### 一元运算符重载
一元运算符只对一个操作数进行操作
- 递增运算符（ ++ ）和递减运算符（ -- ）
- 一元减运算符，即负号（ - ）
- 逻辑非运算符（ ! ）

一元运算符通常出现在它们所操作的对象的左边，比如 `!obj`、`-obj` 和 `++obj`，但有时它们也可以作为后缀，比如 `obj++` 或 `obj--`。
```cpp
#include <iostream>
using namespace std;
 
class Distance
{
   private:
      int feet;             // 0 到无穷
      int inches;           // 0 到 12
   public:
      // 所需的构造函数
      Distance(){
         feet = 0;
         inches = 0;
      }
      Distance(int f, int i){
         feet = f;
         inches = i;
      }
      // 显示距离的方法
      void displayDistance()
      {
         cout << "F: " << feet << " I:" << inches <<endl;
      }
      // 重载负运算符（ - ）
      Distance operator- ()  
      {
         feet = -feet;
         inches = -inches;
         return Distance(feet, inches); // 既修改了当前对象，又返回了一个新对象
      }
};
int main()
{
   Distance D1(11, 10), D2(-5, 11);
 
   -D1;                     // 取相反数
   D1.displayDistance();    // 距离 D1
 
   -D2;                     // 取相反数
   D2.displayDistance();    // 距离 D2
 
   return 0;
}
```

#### `++` 和 `--` 运算符重载
下面的实例演示了如何重载递增运算符（ ++ ），包括前缀和后缀两种用法。注意，int 在 括号内是为了向编译器说明这是一个后缀形式，而不是表示整数。
```cpp
#include <iostream>
using namespace std;
 
class Time
{
   private:
      int hours;             // 0 到 23
      int minutes;           // 0 到 59
   public:
      // 所需的构造函数
      Time(){
         hours = 0;
         minutes = 0;
      }
      Time(int h, int m){
         hours = h;
         minutes = m;
      }
      // 显示时间的方法
      void displayTime()
      {
         cout << "H: " << hours << " M:" << minutes <<endl;
      }
      // 重载前缀递增运算符（ ++ ）
      Time operator++ ()  
      {
         ++minutes;          // 对象加 1
         if(minutes >= 60)  
         {
            ++hours;
            minutes -= 60;
         }
         return Time(hours, minutes);
      }
      // 重载后缀递增运算符（ ++ ）
      Time operator++( int )         
      {
         // 保存原始值
         Time T(hours, minutes);
         // 对象加 1
         ++minutes;                    
         if(minutes >= 60)
         {
            ++hours;
            minutes -= 60;
         }
         // 返回旧的原始值
         return T; 
      }
};
int main()
{
   Time T1(11, 59), T2(10,40);
 
   ++T1;                    // T1 加 1
   T1.displayTime();        // 显示 T1
   ++T1;                    // T1 再加 1
   T1.displayTime();        // 显示 T1
 
   T2++;                    // T2 加 1
   T2.displayTime();        // 显示 T2
   T2++;                    // T2 再加 1
   T2.displayTime();        // 显示 T2
   return 0;
}
```

1. 递增和递减一般是改变对象的状态，所以一般是重载为成员函数。
2. 重载递增递减，一定要和指针的递增递减区分开。因为这里的重载操作的是对象，而不是指针(由于指针是内置类型，指针的递增递减是无法重载的)，所以一般情况的递增递减是操作对象内部的成员变量。
3. 递增和递减分为前置和后置情况，a = ++b;(前置)， a = b++;(后置)。因为符号一样，所以给后置版本加一个int形参作为区分，这个形参是0，但是在函数体中是用不到的，只是为了区分前置后置。

在前缀递增时，若想要实现 ++(++a) 这种连续自加，就要返回其对象的引用，这样才能保证操作的是同一块内存空间，否则就只是单纯的赋值操作，原来的对象并未被修改。
```cpp
#include <iostream>
using namespace std;
class Complex {
private:
    double i;
    double j;
public:
    Complex(int = 0, int = 0);
    void display();
    Complex& operator ++();//前缀自增
    Complex operator ++(int);//后缀自增，参数需要加int
};

Complex::Complex(int a, int b) {
    i = a;
    j = b;
}

void Complex::display() {
    cout << "i="<< i <<"\tj="<< j << endl;
}

Complex& Complex::operator ++() {
    ++i;
    ++j;
    return *this;
}

Complex Complex::operator ++(int) {
    Complex temp = *this;
    ++* this;
    return temp;
}

int main()
{
    Complex comnum1(2, 2), comnum2, comnum3;
    cout << "自增计算前:" << endl;
    cout << "comnum1:";
    comnum1.display();
    cout << "comnum2:";
    comnum2.display();
    cout << "comnum3:";
    comnum3.display();
    cout << endl;

    cout << "前缀自增计算后：" << endl;
    comnum2 = ++comnum1;
    cout << "comnum1:";
    comnum1.display();
    cout << "comnum2:";
    comnum2.display();
    cout << endl;

    cout << "后缀自增计算后:" << endl;
    comnum3 = comnum1++;
    cout << "comnum1:";
    comnum1.display();
    cout << "comnum3:";
    comnum3.display();

    cout << "前缀递增加引用是为了连续自加++(++a)" << endl;
    Complex comcum4;
    ++(++comcum4);
    cout << "comcum4:";
    comcum4.display();

    return 0;
}
```

### 二元运算符重载
二元运算符需要两个参数，当 2 个对象相加时是没有顺序要求的，但要重载 + 让其与一个数字相加则有顺序要求(要求左操作数必须是当前类的对象),意味着:
```cpp
A a1;
a1 + 5;  // ✅ 正确：a1是左操作数，调用a1.operator+(5)
5 + a1;  // ❌ 错误：5不是A类对象，不能调用5.operator+(a1)
```

可以通过加一个友元函数使另一个顺序的输入合法(友元函数不是成员函数，所以它没有隐含的this指针，可以自由定义参数顺序)
```cpp
当编译器遇到 5 + a1 时：
查找匹配的运算符函数

找到友元函数 operator+(int, A)

调用友元函数：operator+(5, a1)

在友元函数内部：通过 obj + b 调用成员函数 a1.operator+(5)

a1 + a2  →  a1.operator+(a2)      // 成员函数
a1 + 5   →  a1.operator+(5)       // 成员函数  
5 + a1   →  operator+(5, a1)      // 友元函数 → 内部调用 a1.operator+(5)
```
完整实现如下：
```cpp
#include<iostream>
using namespace std;
class A
{
    private:
        int a;
    public:
            A();
            A(int n);
            A operator+(const A & obj);
            A operator+(const int b);
    friend A operator+(const int b, A obj); 
            void display(); 
} ;
A::A()
{
    a=0;
}
A::A(int n)//构造函数 
{
    a=n;
}
A A::operator +(const A& obj)//重载+号用于 对象相加 
{
    return this->a+obj.a;
}
A A::operator+(const int b)//重载+号用于  对象与数相加
{
    return A(a+b);
}
A operator+(const int b,  A obj)
{
    return obj+b;//友元函数调用第二个重载+的成员函数  相当于 obj.operator+(b); 
}
void A::display()
{
    cout<<a<<endl;
}
int main ()
{
    A a1(1);
    A a2(2);
    A a3,a4,a5;
    a1.display();
    a2.display();
    int m=1;
    a3=a1+a2;//可以交换顺序，相当月a3=a1.operator+(a2); 
    a3.display();
    a4=a1+m;//因为加了个友元函数所以也可以交换顺序了。
    a4.display();
    a5=m+a1;
    a5.display();
}
```
结果：
```cpp
1
2
3
2
2
```

### 关系运算符重载
C++ 语言支持各种关系运算符（ < 、 > 、 <= 、 >= 、 == 等等），它们可用于比较 C++ 内置的数据类型。

可以重载任何一个关系运算符，重载后的关系运算符可用于比较类的对象。

下面的实例演示了如何重载 < 运算符：
```cpp
#include <iostream>
using namespace std;
 
class Distance
{
   private:
      int feet;             // 0 到无穷
      int inches;           // 0 到 12
   public:
      // 所需的构造函数
      Distance(){
         feet = 0;
         inches = 0;
      }
      Distance(int f, int i){
         feet = f;
         inches = i;
      }
      // 显示距离的方法
      void displayDistance()
      {
         cout << "F: " << feet << " I:" << inches <<endl;
      }
      // 重载负运算符（ - ）
      Distance operator- ()  
      {
         feet = -feet;
         inches = -inches;
         return Distance(feet, inches);
      }
      // 重载小于运算符（ < ）
      bool operator <(const Distance& d)
      {
         if(feet < d.feet)
         {
            return true;
         }
         if(feet == d.feet && inches < d.inches)
         {
            return true;
         }
         return false;
      }
};
int main()
{
   Distance D1(11, 10), D2(5, 11);
 
   if( D1 < D2 )
   {
      cout << "D1 is less than D2 " << endl;
   }
   else
   {
      cout << "D2 is less than D1 " << endl;
   }
   return 0;
}
```

###　输入/输出运算符重载
C++ 能够使用流提取运算符 >> 和流插入运算符 << 来输入和输出内置的数据类型。在这里，有一点很重要，我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。

下面的实例演示了如何重载提取运算符 >> 和插入运算符 <<。
```cpp
#include <iostream>
using namespace std;
 
class Distance
{
   private:
      int feet;             // 0 到无穷
      int inches;           // 0 到 12
   public:
      // 所需的构造函数
      Distance(){
         feet = 0;
         inches = 0;
      }
      Distance(int f, int i){
         feet = f;
         inches = i;
      }
      friend ostream &operator<<( ostream &output, 
                                       const Distance &D )
      { 
         output << "F : " << D.feet << " I : " << D.inches;
         return output;            
      }
 
      friend istream &operator>>( istream  &input, Distance &D )
      { 
         input >> D.feet >> D.inches;
         return input;            
      }
};
int main()
{
   Distance D1(11, 10), D2(5, 11), D3;
 
   cout << "Enter the value of object : " << endl;
   cin >> D3;
   cout << "First Distance : " << D1 << endl;
   cout << "Second Distance :" << D2 << endl;
   cout << "Third Distance :" << D3 << endl;
 
 
   return 0;
}
```
为什么需要友元函数？

因为运算符的左操作数是流对象(cin/cout)，不是 Distance 对象，所以不能作为成员函数重载：
```cpp
// 这样是不行的：
D1 << cout;  // 不符合使用习惯
D3 >> cin;   // 不符合使用习惯

// 我们需要这样：
cout << D1;  // 符合习惯
cin >> D3;   // 符合习惯
```

### 赋值运算符重载
可以重载赋值运算符（ = ），用于创建一个对象，比如拷贝构造函数。
```cpp
#include <iostream>
using namespace std;
 
class Distance
{
   private:
      int feet;             // 0 到无穷
      int inches;           // 0 到 12
   public:
      // 所需的构造函数
      Distance(){
         feet = 0;
         inches = 0;
      }
      Distance(int f, int i){ 
         feet = f;
         inches = i;
      }
      void operator=(const Distance &D )
      { 
         feet = D.feet;
         inches = D.inches;
      }
      // 显示距离的方法
      void displayDistance()
      {
         cout << "F: " << feet <<  " I:" <<  inches << endl;
      }
      
};
int main()
{
   Distance D1(11, 10), D2(5, 11);
 
   cout << "First Distance : "; 
   D1.displayDistance();
   cout << "Second Distance :"; 
   D2.displayDistance();
 
   // 使用赋值运算符
   D1 = D2;
   cout << "First Distance :"; 
   D1.displayDistance();
 
   return 0;
}
```

### 函数调用运算符 () 重载
函数调用运算符 () 可以被重载用于类的对象。当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数。
```cpp
#include <iostream>
using namespace std;
 
class Distance
{
   private:
      int feet;             // 0 到无穷
      int inches;           // 0 到 12
   public:
      // 所需的构造函数
      Distance(){
         feet = 0;
         inches = 0;
      }
      Distance(int f, int i){
         feet = f;
         inches = i;
      }
      // 重载函数调用运算符
      Distance operator()(int a, int b, int c)
      {
         Distance D;
         // 进行随机计算
         D.feet = a + c + 10;
         D.inches = b + c + 100 ;
         return D;
      }
      // 显示距离的方法
      void displayDistance()
      {
         cout << "F: " << feet <<  " I:" <<  inches << endl;
      }
      
};
int main()
{
   Distance D1(11, 10), D2;

   cout << "First Distance : "; 
   D1.displayDistance();

   D2 = D1(10, 10, 10); // invoke operator()
   cout << "Second Distance :"; 
   D2.displayDistance();

   return 0;
}

```
该例子中如果重载 operator() 时只使用两个参数，确实会与构造函数的参数列表发生冲突，导致无法区分调用哪个函数。

### 下标运算符 [] 重载
下标操作符 [] 通常用于访问数组元素。重载该运算符用于增强操作 C++ 数组的功能。
```cpp
#include <iostream>
using namespace std;
const int SIZE = 10;
 
class safearay
{
   private:
      int arr[SIZE];
   public:
      safearay() 
      {
         register int i;
         for(i = 0; i < SIZE; i++)
         {
           arr[i] = i;
         }
      }
      int& operator[](int i)
      {
          if( i >= SIZE )
          {
              cout << "索引超过最大值" <<endl; 
              // 返回第一个元素
              return arr[0];
          }
          return arr[i];
      }
};
int main()
{
   safearay A;
 
   cout << "A[2] 的值为 : " << A[2] <<endl;
   cout << "A[5] 的值为 : " << A[5]<<endl;
   cout << "A[12] 的值为 : " << A[12]<<endl;
 
   return 0;
}
```

### 类成员访问运算符 -> 重载
类成员访问运算符（ -> ）可以被重载，但它较为麻烦。它被定义用于为一个类赋予"指针"行为。运算符 -> 必须是一个成员函数。如果使用了 -> 运算符，返回类型必须是指针或者是类的对象。

运算符 -> 通常与指针引用运算符 * 结合使用，用于实现"智能指针"的功能。这些指针是行为与正常指针相似的对象，唯一不同的是，当您通过指针访问对象时，它们会执行其他的任务。比如，当指针销毁时，或者当指针指向另一个对象时，会自动删除对象。

间接引用运算符 -> 可被定义为一个一元后缀运算符。
```cpp
#include <iostream>
#include <vector>
using namespace std;
 
// 假设一个实际的类
class Obj {
   static int i, j;
public:
   void f() const { cout << i++ << endl; }
   void g() const { cout << j++ << endl; }
};
 
// 静态成员定义
int Obj::i = 10;
int Obj::j = 12;
 
// 为上面的类实现一个容器
class ObjContainer {
   vector<Obj*> a;
public:
   void add(Obj* obj)
   { 
      a.push_back(obj);  // 调用向量的标准方法
   }
   friend class SmartPointer;
};
 
// 实现智能指针，用于访问类 Obj 的成员
class SmartPointer {
   ObjContainer oc;
   int index;
public:
   SmartPointer(ObjContainer& objc)
   { 
       oc = objc;
       index = 0;
   }
   // 返回值表示列表结束
   bool operator++() // 前缀版本
   { 
     if(index >= oc.a.size() - 1) return false;
     if(oc.a[++index] == 0) return false;
     return true;
   }
   bool operator++(int) // 后缀版本
   { 
      return operator++();
   }
   // 重载运算符 ->
   Obj* operator->() const 
   {
     if(!oc.a[index])
     {
        cout << "Zero value";
        return (Obj*)0;
     }
     return oc.a[index];
   }
};
 
int main() {
   const int sz = 10;
   Obj o[sz];
   ObjContainer oc;
   for(int i = 0; i < sz; i++)
   {
       oc.add(&o[i]);
   }
   SmartPointer sp(oc); // 创建一个迭代器
   do {
      sp->f(); // 智能指针调用
      sp->g();
   } while(sp++);
   return 0;
}
```

## 多态
当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。

C++ 多态允许使用基类指针或引用来调用子类的重写方法，从而使得同一接口可以表现不同的行为。

多态使得代码更加灵活和通用，程序可以通过基类指针或引用来操作不同类型的对象，而不需要显式区分对象类型。这样可以使代码更具扩展性，在增加新的形状类时不需要修改主程序。

以下是多态的几个关键点：

虚函数（Virtual Functions）：

- 在基类中声明一个函数为虚函数，使用关键字virtual。
- 派生类可以重写（override）这个虚函数。
- 调用虚函数时，会根据对象的实际类型来决定调用哪个版本的函数。

动态绑定（Dynamic Binding）：

- 也称为晚期绑定（Late Binding），在运行时确定函数调用的具体实现。
- 需要使用指向基类的指针或引用来调用虚函数，编译器在运行时根据对象的实际类型来决定调用哪个函数。

纯虚函数（Pure Virtual Functions）：

- 一个包含纯虚函数的类被称为抽象类（Abstract Class），它不能被直接实例化。
- 纯虚函数没有函数体，声明时使用= 0。
- 它强制派生类提供具体的实现。

多态的实现机制：

- 虚函数表（V-Table）：C++运行时使用虚函数表来实现多态。每个包含虚函数的类都有一个虚函数表，表中存储了指向类中所有虚函数的指针。
- 虚函数指针（V-Ptr）：对象中包含一个指向该类虚函数表的指针。

使用多态的优势：

- 代码复用：通过基类指针或引用，可以操作不同类型的派生类对象，实现代码的复用。
- 扩展性：新增派生类时，不需要修改依赖于基类的代码，只需要确保新类正确重写了虚函数。
- 解耦：多态允许程序设计更加模块化，降低类之间的耦合度。

注意事项：

- 只有通过基类的指针或引用调用虚函数时，才会发生多态。
- 如果直接使用派生类的对象调用函数，那么调用的是派生类中的版本，而不是基类中的版本。
- 多态性需要运行时类型信息（RTTI），这可能会增加程序的开销。

```cpp
#include <iostream>
using namespace std;

// 基类 Animal
class Animal {
public:
    // 虚函数 sound，为不同的动物发声提供接口
    virtual void sound() const {
        cout << "Animal makes a sound" << endl;
    }
    
    // 虚析构函数确保子类对象被正确析构
    virtual ~Animal() { 
        cout << "Animal destroyed" << endl; 
    }
};

// 派生类 Dog，继承自 Animal
class Dog : public Animal {
public:
    // 重写 sound 方法
    void sound() const override {
        cout << "Dog barks" << endl;
    }
    
    ~Dog() {
        cout << "Dog destroyed" << endl;
    }
};

// 派生类 Cat，继承自 Animal
class Cat : public Animal {
public:
    // 重写 sound 方法
    void sound() const override {
        cout << "Cat meows" << endl;
    }
    
    ~Cat() {
        cout << "Cat destroyed" << endl;
    }
};

// 测试多态
int main() {
    Animal* animalPtr;  // 基类指针

    // 创建 Dog 对象，并指向 Animal 指针
    animalPtr = new Dog();
    animalPtr->sound();  // 调用 Dog 的 sound 方法
    delete animalPtr;    // 释放内存，调用 Dog 和 Animal 的析构函数

    // 创建 Cat 对象，并指向 Animal 指针
    animalPtr = new Cat();
    animalPtr->sound();  // 调用 Cat 的 sound 方法
    delete animalPtr;    // 释放内存，调用 Cat 和 Animal 的析构函数

    return 0;
}
```
关键概念

- 虚函数：通过在基类中使用 virtual 关键字声明虚函数，派生类可以重写这个函数，从而使得在运行时根据对象类型调用正确的函数。

- 动态绑定：C++ 的多态通过动态绑定实现。在运行时，基类指针 animalPtr 会根据它实际指向的对象类型（Dog 或 Cat）调用对应的 sound() 方法。

- 虚析构函数：在具有多态行为的基类中，析构函数应该声明为 virtual，以确保在删除派生类对象时调用派生类的析构函数，防止资源泄漏。

```cpp
#include <iostream>
using namespace std;
 
// 基类 Shape，表示形状
class Shape {
   protected:
      int width, height; // 宽度和高度
 
   public:
      // 构造函数，带有默认参数
      Shape(int a = 0, int b = 0) : width(a), height(b) { }
 
      // 虚函数 area，用于计算面积
      // 使用 virtual 关键字，实现多态
      virtual int area() {
         cout << "Shape class area: " << endl;
         return 0;
      }
};
 
// 派生类 Rectangle，表示矩形
class Rectangle : public Shape {
   public:
      // 构造函数，使用基类构造函数初始化 width 和 height
      Rectangle(int a = 0, int b = 0) : Shape(a, b) { }
 
      // 重写 area 函数，计算矩形面积
      int area() override { 
         cout << "Rectangle class area: " << endl;
         return width * height;
      }
};
 
// 派生类 Triangle，表示三角形
class Triangle : public Shape {
   public:
      // 构造函数，使用基类构造函数初始化 width 和 height
      Triangle(int a = 0, int b = 0) : Shape(a, b) { }
 
      // 重写 area 函数，计算三角形面积
      int area() override { 
         cout << "Triangle class area: " << endl;
         return (width * height / 2); 
      }
};
 
// 主函数
int main() {
   Shape *shape;           // 基类指针
   Rectangle rec(10, 7);   // 矩形对象
   Triangle tri(10, 5);    // 三角形对象
 
   // 将基类指针指向矩形对象，并调用 area 函数
   shape = &rec;
   cout << "Rectangle Area: " << shape->area() << endl;
 
   // 将基类指针指向三角形对象，并调用 area 函数
   shape = &tri;
   cout << "Triangle Area: " << shape->area() << endl;
 
   return 0;
}
```

### 纯虚函数
您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

纯虚函数是没有实现的虚函数，在基类中用 = 0 来声明。

纯虚函数表示基类定义了一个接口，但具体实现由派生类负责。

纯虚函数使得基类变为抽象类（abstract class），无法实例化。

特点：

- 必须在基类中声明为 = 0，表示没有实现，子类必须重写。
- 抽象类：包含纯虚函数的类不能直接实例化，必须通过派生类实现所有纯虚函数才能创建对象。
- 接口定义：纯虚函数通常用于定义接口，让派生类实现具体行为。

例如：
```cpp
#include <iostream>
using namespace std;
 
class Shape {
public:
    virtual int area() = 0;  // 纯虚函数，强制子类实现此方法
};
 
class Rectangle : public Shape {
private:
    int width, height;
public:
    Rectangle(int w, int h) : width(w), height(h) { }
    
    int area() override {  // 实现纯虚函数
        return width * height;
    }
};
 
int main() {
    Shape *shape = new Rectangle(10, 5);
    cout << "Rectangle Area: " << shape->area() << endl;  // 输出: Rectangle Area: 50
    delete shape;
}
```
<img width="1020" height="301" alt="image" src="https://github.com/user-attachments/assets/26b71598-9030-4a8a-b24f-4b2ee6070c84" />

## 数据抽象
数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。

数据抽象是一种依赖于接口和实现分离的编程（设计）技术。

### 访问标签强制抽象
在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：

- 使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。
- 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。

访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。

### 数据抽象的实例
C++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。
```cpp
#include <iostream>
using namespace std;
 
class Adder{
   public:
      // 构造函数
      Adder(int i = 0)
      {
        total = i;
      }
      // 对外的接口
      void addNum(int number)
      {
          total += number;
      }
      // 对外的接口
      int getTotal()
      {
          return total;
      };
   private:
      // 对外隐藏的数据
      int total;
};
int main( )
{
   Adder a;
   
   a.addNum(10);
   a.addNum(20);
   a.addNum(30);
 
   cout << "Total " << a.getTotal() <<endl;
   return 0;
}
```

## 数据封装
数据封装（Data Encapsulation）是面向对象编程（OOP）的一个基本概念，它通过将数据和操作数据的函数封装在一个类中来实现。这种封装确保了数据的私有性和完整性，防止了外部代码对其直接访问和修改。

所有的 C++ 程序都有以下两个基本要素：

- 程序语句（代码）：这是程序中执行动作的部分，它们被称为函数。
- 程序数据：数据是程序的信息，会受到程序函数的影响。

封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即数据隐藏。

数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。

C++ 通过创建类来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。

为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 public 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。

把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。
```cpp
#include <iostream>
using namespace std;
 
class Adder{
   public:
      // 构造函数
      Adder(int i = 0)
      {
        total = i;
      }
      // 对外的接口
      void addNum(int number)
      {
          total += number;
      }
      // 对外的接口
      int getTotal()
      {
          return total;
      };
   private:
      // 对外隐藏的数据
      int total;
};
int main( )
{
   Adder a;
   
   a.addNum(10);
   a.addNum(20);
   a.addNum(30);
 
   cout << "Total " << a.getTotal() <<endl;
   return 0;
}
```

C++中, 虚函数可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。

一个成员函数被定义为private属性，标志着其只能被当前类的其他成员函数(或友元函数)所访问。而virtual修饰符则强调父类的成员函数可以在子类中被重写，因为重写之时并没有与父类发生任何的调用关系，故而重写是被允许的。

编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论他们是private、protect或是public的，都会被统一的放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表（相同偏移地址指，各虚函数相对于VPTR指针的偏移），则子类就会被允许对这些虚函数进行重载。且重载时可以给重载函数定义新的属性，例如public，其只标志着该重载函数在该子类中的访问属性为public，和父类的private属性没有任何关系！

纯虚函数可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利。

### 数据封装和数据抽象概念的区别

关注点不同：

- 封装关注的是数据和操作方法的绑定，以及对外部访问的控制。
- 抽象关注的是简化复杂性，通过隐藏实现细节来只暴露对象的主要特性和功能。

实现方式：

- 封装通过访问控制（如 private、protected 和 public 访问修饰符）实现。
- 抽象通过抽象类和接口（纯虚函数等）实现。

目的：

- 封装主要是为了数据保护和隐藏实现细节。
- 抽象主要是为了简化复杂性和提高代码的可读性与可维护性。

侧重点：

- 封装侧重于对象内部的设计，通过隐藏数据和提供访问方法来保护对象的内部状态。
- 抽象侧重于对象对外的接口设计，通过提供简化的接口来隐藏复杂的实现细节。

## 接口（抽象类）
接口描述了类的行为和功能，而不需要完成类的特定实现。

C++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。

如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。

设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。

因此，如果一个 ABC 的子类需要被实例化，则必须实现每个纯虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。

可用于实例化对象的类被称为具体类。

经典：

定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

## 文件和流
iostream 标准库，提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。从文件读取流和向文件写入流需要用到 C++ 中另一个标准库 fstream。
<img width="1019" height="247" alt="image" src="https://github.com/user-attachments/assets/9102b41c-b882-4234-962c-306f3e46e83c" />

要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。

### 打开文件
在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。

下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。
```cpp
void open(const char *filename, ios::openmode mode);.

```











































## 智能指针

### 什么是智能指针？

智能指针不是指针，是一个管理指针的类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆[内存泄漏](https://so.csdn.net/so/search?q=内存泄漏&spm=1001.2101.3001.7020)和空悬指针等等问题。

动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。

### 为什么需要智能指针

#### 内存泄漏

##### 什么是内存泄漏

**内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。**

内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

##### 危害

长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现 内存泄漏会导致响应越来越慢，最终卡死。

#### 防止内存泄漏

```cpp
void fxx()
{
	int* p1 = new int[10];
	int* p2 = new int[20];
    int* p3 = new int[30];
 
	//...
 
	delete[] p1;
	delete[] p2;
	delete[] p3;
}
```

如果指针p2或者p3开辟空间new错误，这里就会导致后面的delete不会被执行，这就导致了指针p1的**内存泄漏**。

### 智能指针的原理与使用

#### 智能指针的原理

智能指针的基本原理是利用RAII。

RAII：RAII（Resource Acquisition Is Initialization）是一种利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的简单技术。

**在对象构造时获取资源**，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在 **对象析构的时候释放资源**。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做 法有两大好处：

- 不需要显式地释放资源。
- 采用这种方式，对象所需的资源在其生命期内始终保持有效。

```cpp
template<class T>
class Smartptr
{
public:
	//RAII
	Smartptr(T* ptr)
		:_ptr(ptr)
	{}
	~Smartptr()
	{
		cout << "delete:" << _ptr << endl;
		delete _ptr;
	}
 
	//像指针一样
	T& operator*()
	{
		return *_ptr;
	}
	T* operator->()
	{
		return _ptr;
	}
private:
	T* _ptr;
};
 
int main()
{
    Smartptr<int> sp1(new int(1));
	Smartptr<int> sp2(new int(2));
	*sp1 += 10;
	Smartptr<pair<string, int>> sp3(new pair<string, int>);
	sp3->first = "apple";
	sp3->second = 1;
	return 0;
}
```

```cpp
template<class T>
class Smartptr
{
public:
	//RAII
	Smartptr(T* ptr)
		:_ptr(ptr)
	{}
	~Smartptr()
	{
		cout << "delete:" << _ptr << endl;
		delete _ptr;
	}
 
	//像指针一样
	T& operator*()
	{
		return *_ptr;
	}
	T* operator->()
	{
		return _ptr;
	}
private:
	T* _ptr;
};
 
int div()
{
	int a, b;
	cin >> a >> b;
	if (b == 0)
	{
		throw invalid_argument("除0错误");
	}
	return a / b;
}
void func()
{
	Smartptr<int> sp1(new int(1));
	Smartptr<int> sp2(new int(2));
	*sp1 += 10;
	cout << div() << endl;
}
int main()
{
	try
	{
		func();
	}
	catch (const exception& e)
	{
		cout << e.what() << endl;
	}
	return 0;
}
```

通过SmartPtr对象，无论程序是正常执行结束，还是因为某些中途原因进行返回，或者抛出异常等开始所面临的困境，只要SmartPtr对象的生命周期结束就会自动调用对应的析构函数，不会造成内存泄漏，完成资源释放。

#### 智能指针的拷贝问题

如果我们用一个智能指针拷贝构造一个智能指针，或者用一个智能指针赋值给另一个智能指针。这样的操作都会导致程序崩溃。

```cpp
void test()
{
	SmartPtr<int> sp1(new int);
	SmartPtr<int> sp2(sp1);//拷贝构造
	SmartPtr<int> sp3(new int);
	SmartPtr<int> sp4 = sp3;//赋值
}
```

因为对于我们的智能指针来说，将sp1拷贝给sp2操作是浅拷贝，是将两个指针的指向统一到一块空间。当sp1和sp2释放时，会导致这块空间释放两次。同样的道理，将sp3赋值给sp4的时候，也只是单纯的将指针的指向指到同一块空间，这样在析构的时候也会导致析构两次。

### 智能指针的众多版本

C++中存在4种智能指针：auto_ptr,unquie_ptr,shared_ptr,weak_ptr，他们各有优缺点，以及对应的实用场景。

#### auto_ptr

auto_ptr ：管理权转移，被拷贝对象把资源管理权转移给拷贝对象，导致被拷贝对象悬空。

auto_ptr是C++98的，通过管理权转移的方式解决智能指针拷贝问题，保证了一个资源只有一个对象对其进行管理，这时候一个资源就不会被多个释放：

```cpp
int main()
{
	yjy::auto_ptr<int> ap1(new int(1));
	yjy::auto_ptr<int> ap2(ap1);
 
	*ap2 += 10;
 
	//ap1悬空
	//*ap1 += 10;
 
	return 0;
}
```

构造对象获取资源，析构对象释放资源。对*和->运算符进行重载，使其像指针一样。拷贝构造函数，用传入的对象的资源来构造当前对象，并将传入对象管理资源指针悬空。

#### unique_ptr

需要引用memory库来使用。

unique_ptr是C++11中的智能指针，unique_ptr来的更直接：**直接防止拷贝**的方式解决智能指针的拷贝问题，简单而又粗暴，防止智能指针对象拷贝，保证资源不会被多次释放，但是防止拷贝也不是解决问题的好办法，因为在很多场景下是需要拷贝的。

#### shared_ptr

shared_ptr是C++11的智能指针，通过**引用计数**的方式解决智能指针的拷贝问题。

- shared_ptr在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共 享。
- 在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减 一。如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源；
- 如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对 象就成野指针了。

 引用计数的方式能够支持多个对象一起管理一个资源，也就支持智能指针的拷贝，只有当资源的引用计数减为0时才会释放，保证了同一个资源不会被多次释放。



shared_ptr的美中不足的地方：循环引用

```cpp
struct ListNode
{
	int _val;
	yjy::shared_ptr<ListNode> _next;
	yjy::shared_ptr<ListNode> _prev;
 
	ListNode(int val = 0)
		:_val(val)
	{}
 
	~ListNode()
	{
		cout << "ListNode" << endl;
	}
};
 
int main()
{
	yjy::shared_ptr<ListNode> n1(new ListNode(10));
	yjy::shared_ptr<ListNode> n2(new ListNode(20));
 
	cout << n1.use_count() << endl;
	cout << n2.use_count() << endl;
 
	n1->_next = n2;
	n2->_next = n1;
 
	cout << n1.use_count() << endl;
	cout << n2.use_count() << endl;
	return 0;
}
```

我们可以看到定义了两个对象，对象里面的prev和next对应指向另一个对象，这时候我们的shared_ptr就会存在缺陷。

![img](https://i-blog.csdnimg.cn/direct/75006c5e9c3147e79733f34bc3d7df3c.png)

在我们出作用域销毁的时候，会发生下面的情况：

**n2对象销毁时-》_prev指针释放-》n1对象销毁-》_next指针释放-》n2对象销毁**

可以看到这个销毁的过程是一个互相影响的过程，是一个死循环。这样的结构就是我们的循环引用。该怎么办呢？

#### weak_ptr

`std::weak_ptr` 是 C++11 引入的一个智能指针，它是对 `std::shared_ptr` 的一个补充。`std::weak_ptr` 不控制所指向对象的使用寿命，也就是说，它不会增加所指向对象的引用计数。其主要用途是观察一个由 `std::shared_ptr` 所管理的对象，而不会在对象的生命周期中持有所有权。

`std::weak_ptr` 的主要特性和用途：

1. **不拥有对象**：与 `std::shared_ptr` 不同，`std::weak_ptr` 不拥有其指向的对象。这意味着，当最后一个 `std::shared_ptr` 被销毁或重置时，即使还有 `std::weak_ptr` 指向该对象，对象也会被销毁。
2. **防止循环引用**：当两个或更多的 `std::shared_ptr` 相互引用时，它们会形成一个循环引用，导致它们所指向的对象无法被正确销毁。通过使用 `std::weak_ptr` 来打破这种循环引用，可以确保对象在不再需要时被正确销毁。
3. **转换为 `std::shared_ptr`**：尽管 `std::weak_ptr` 不拥有对象，但它可以安全地转换为 `std::shared_ptr`（如果对象仍然存在）。这种转换会增加对象的引用计数，确保在转换后的 `std::shared_ptr` 生命周期内对象不会被销毁。
4. **检查对象是否存在**：可以使用 `std::weak_ptr` 的 `expired()` 成员函数来检查它所指向的对象是否仍然存在。

```cpp
//不支持RAII，不参与资源管理
template<class T>
class weak_ptr
{
public:
	//RAII
	weak_ptr()
		:_ptr(nullptr)
	{}
 
	weak_ptr(const shared_ptr<T>& wp)
	{
		_ptr = wp.get();
	}
 
	weak_ptr<T>& operator=(const shared_ptr<T>& wp)
	{
		_ptr = wp.get();
		return *this;
	}
 
	// 像指针一样
	T& operator*()
	{
		return *_ptr;
	}
 
	T* operator->()
	{
		return _ptr;
	}
private:
	T* _ptr;
};
```

 这里的weak_ptr就不涉及RAII，不参与资源管理，从根源上杜绝了这个问题

## 红黑树

红黑树是一种自平衡二叉查找树。红黑树的特点如下：

- 每个节点非红即黑。

- 根节点总是黑色的。

- 每个叶子节点都是黑色的空节点（NIL 节点）。

- 如果节点是红色的，则它的子节点必须是黑色的（反之不一定），通常这条规则也叫不会有连续的红色节点。

- 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

- 性质 1. 节点是红色或黑色。

- 性质 2. 根节点是黑色。

- 性质 3. 每个叶节点（NIL 节点，空节点）是黑色的。

- 性质 4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

- 性质 5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

### 红黑树与其他数据结构的对比

#### 1. 与二叉树对比

​    二叉树没有自平衡机制，可能导致树的不平衡。例如，当大量插入有序数据时，二叉树可能会变得线性化，结构不平衡。而红黑树通过节点的颜色标记和旋转操作来保持平衡。红黑树中的每个节点非红即黑，根节点总是黑色的，红色节点的两个子节点必须是黑色的，从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。这些规则确保了红黑树在插入和删除节点时能够保持相对平衡，避免出现极端不平衡的情况。

#### 2. 与 AVL 树对比

​    AVL 树对平衡性要求更高，在任何节点的左右子树高度差不超过 1。这使得 AVL 树在插入和删除操作时的性能开销较大，因为需要频繁地进行旋转操作来维持平衡。而红黑树更常用于各种常规应用，在插入和删除操作中具有较好的平均和最坏情况时间复杂度。红黑树是一种弱平衡二叉树，它不要求像 AVL 树那样严格的平衡条件，但通过颜色标记和旋转操作，也能保证树的大致平衡，同时减少了旋转操作的次数，提高了性能。

#### 3. 与 B 树和 B + 树对比

​    B 树和 B + 树适用于处理大规模数据和磁盘存储的情况。B 树是一种多路搜索树，每个节点可以包含多个键值对，通过分裂和合并节点来维持平衡。B + 树在 B 树的基础上进行了改进，非叶子节点只存储索引关键字数据，叶子节点数据之间通过双向链表链接，方便范围检索。而红黑树适用于内存中的数据结构。红黑树是一种二叉查找树，通过颜色标记和旋转操作来保持平衡，适用于内存中数据的快速查找、插入和删除操作。它的高度相对较低，能够在 O (logN) 的时间复杂度内完成这些操作。













