# 2025.8.20
给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。

「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。

 
```
示例 1：

输入：s = "011101"
输出：5 
解释：
将字符串 s 划分为两个非空子字符串的可行方案有：
左子字符串 = "0" 且 右子字符串 = "11101"，得分 = 1 + 4 = 5 
左子字符串 = "01" 且 右子字符串 = "1101"，得分 = 1 + 3 = 4 
左子字符串 = "011" 且 右子字符串 = "101"，得分 = 1 + 2 = 3 
左子字符串 = "0111" 且 右子字符串 = "01"，得分 = 1 + 1 = 2 
左子字符串 = "01110" 且 右子字符串 = "1"，得分 = 2 + 1 = 3
```
```
示例 2：

输入：s = "00111"
输出：5
解释：当 左子字符串 = "00" 且 右子字符串 = "111" 时，我们得到最大得分 = 2 + 3 = 5
```
```
示例 3：

输入：s = "1111"
输出：3
```

提示：

- 2 <= s.length <= 500
- 字符串 s 仅由字符 '0' 和 '1' 组成。

# 灵神 - 枚举分割线，O(n) 前后缀分解 / 一次遍历

核心思想：枚举分割线的位置，维护 0 和 1 的个数。

$left_0$ 可以在遍历 s 的过程中计算。

$right_1$ 呢？我们可以在枚举分割线之前，先统计整个 s 中的 1 的个数。

然后再枚举分割线：

如果 `s[i]=0`，那么把 $left_0$ 增加 1。
否则 `s[i]=1`，那么把 $right_1$ 减少 1。因为 s[i] 之前在分割线右侧，现在属于分割线左侧了。

## 写法1

```python
class Solution:
    def maxScore(self, s: str) -> int:
        right1 = s.count('1')
        ans = left0 = 0
        for c in s[:-1]:  # 移动分割线
            if c == '0':
                left0 += 1
            else:  # c == '1'
                right1 -= 1
            ans = max(ans, left0 + right1)
        return ans
```

## 写法2

```python
class Solution:
    def maxScore(self, s: str) -> int:
        score = s.count('1')
        ans = 0
        for c in s[:-1]:
            score += 1 if c == '0' else -1
            ans = max(ans, score)
        return ans
```

## 写法3

```python
class Solution:
    def maxScore(self, s: str) -> int:
        cnt1 = delta = 0
        max_delta = -inf
        for c in s[:-1]:
            cnt1 += 1 if c == '1' else 0
            delta += 1 if c == '0' else -1
            max_delta = max(max_delta, delta)
        return max_delta + cnt1 + int(s[-1])
```

## 复杂度分析

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$


# 我的

```python
class Solution:
    def maxScore(self, s: str) -> int:
        ans  = 0
        for i in range(1,len(s)):
            left = s[:i]
            right = s[i:]
            if left.count('0') + right.count('1') > ans :
                ans  = left.count('0') + right.count('1')
        return ans
```

## 复杂度分析

外层循环运行 `len(s) - 1` 次，即 `O(n)`。

Python 的字符串切片是 `O(k)`，这里 k 最多是 n。
字符串计数是线性扫描，复杂度分别是 `O(i)` 和 `O(n-i)`，最坏情况加起来就是 `O(n)`。

总共有 `O(n)` 次循环，每次 `O(n)` → 总时间复杂度 = `O(n²)`。

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(n)$
