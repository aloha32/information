# 2025.8.20
给你一个数组 nums ，数组中有 2n 个元素，按 `[x1,x2,...,xn,y1,y2,...,yn]` 的格式排列。

请你将数组按 `[x1,y1,x2,y2,...,xn,yn]` 格式重新排列，返回重排后的数组。

 
```
示例 1：

输入：nums = [2,5,1,3,4,7], n = 3
输出：[2,3,5,4,1,7] 
解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]
```
```
示例 2：

输入：nums = [1,2,3,4,4,3,2,1], n = 4
输出：[1,4,2,3,3,2,4,1]
```
```
示例 3：

输入：nums = [1,1,2,2], n = 2
输出：[1,2,1,2]
```

提示：

- 1 <= n <= 500
- nums.length == 2n
- 1 <= nums[i] <= $10^3$

# 空间复杂度为 O(1) 的两种解法（时间依然O(n)）
## 在一个整数里存两个数
这个算法的核心思想是：利用一个 int 类型整数的二进制位，将它拆分成高位和低位两个部分，分别用来存储两个不同的数字。

在 C++ 中，一个 int 通常是 32 位。这个解法基于一个前提（来自 LeetCode 的题目约束）：nums 里的每个数字 nums[i] 的范围是 `1 <= nums[i] <= 1000`。

这个算法就利用了这一点，将一个 32 位的 int 空间分为：
1. 低 10 位: 用来存储原始的数字。
2. 高位 (例如第 10 到 19 位): 用来存储我们想要移动到这个位置的新数字。

作者提供的是cpp实现
```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {

        for(int i = 0; i < 2 * n; i ++){
            int j = i < n ? 2 * i : 2 * (i - n) + 1;
            nums[j] |= (nums[i] & 1023) << 10;
        }
        for(int& e: nums) e >>= 10;
        return nums;
    }
};
```
python实现：
```python
from typing import List

class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        """
        使用位运算实现 O(1) 空间复杂度的数组重排。

        核心思想:
        利用 Python 整数类型有足够多的比特位，将一个整数空间拆分为两部分，
        用低位存储原始数字，高位存储将要移动到该位置的新数字。
        题目约束 nums[i] <= 1000，而 2^10 = 1024，所以 10 个比特位足以存储一个数字。

        步骤:
        1. 编码: 遍历数组，将每个数字 nums[i] 编码到其目标位置 nums[j] 的高10位上。
        2. 解码: 遍历数组，将每个数字右移10位，使得高位的新数字成为最终结果。
        """
        
        # 步骤 1: 编码 - 将新旧两个数字打包到同一个位置
        # 遍历整个数组，长度为 2*n
        for i in range(2 * n):
            # 获取当前元素 nums[i] 的原始值。
            # 使用 & 1023 (二进制为 0...1111111111) 是为了确保我们只取低10位，
            # 以防 nums[i] 本身已经被其他数字编码过（高位有了值）。
            original_val = nums[i] & 1023
            
            # 计算 nums[i] 应该去的目标位置 j
            if i < n:
                # x_i 的目标位置是 2*i
                j = 2 * i
            else:
                # y_i 的目标位置是 2*(i-n) + 1
                j = 2 * (i - n) + 1
            
            # 将 original_val 左移 10 位，然后用“按位或”操作存入 nums[j] 的高位。
            # nums[j] 的低10位保持不变，存储着它自己的原始值。
            nums[j] |= (original_val << 10)

        # 步骤 2: 解码 - 提取新数字，丢弃旧数字
        # 此时，每个 nums[j] 的高10位是新值，低10位是旧值。
        for i in range(2 * n):
            # 将每个元素向右移动 10 位。
            # 这会把存储在高位的新数字移动到低位，并直接丢弃原先在低位的旧数字。
            nums[i] >>= 10
            
        return nums
```

### 复杂度分析

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

## 环状替换 (Cycle Sort) 或循环置换
核心思想
1. 寻找正确位置: 对于每个位置 i 上的数字，我们计算出它最终应该去的目标位置 j。
2. 链式交换: 我们将 `nums[i]` 换到 `nums[j]`。但现在 `nums[j]` 原来的值被换到了 `nums[i]`，这个被换过来的新值也需要被放到它自己的正确位置。于是，我们以 `nums[i]` 为“中转站”，形成一个交换链，直到一个元素被换入 `nums[i]`，而这个元素恰好就属于位置 i，这时一个“环”就闭合了。
3. 使用负号标记: 我们如何知道一个位置上的元素是否已经是我们排好的最终元素了？ 答案是，每当一个元素被放置到其正确的最终位置时，我们就把它变成负数。这样，`if(nums[i] > 0)` 这个判断条件就能保证我们不会重复处理已经就位的元素。

作者提供的是cpp实现
```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {

        for(int i = 0; i < 2 * n; i ++)
            if(nums[i] > 0){
                
                // j 描述当前的 nums[i] 对应的索引，初始为 i
                int j = i; 

                while(nums[i] > 0){

                    // 计算 j 索引的元素，也就是现在的 nums[i]，应该放置的索引
                    j = j < n ? 2 * j : 2 * (j - n) + 1; 

                    // 把 nums[i] 放置到 j 的位置，
                    // 同时，把 nums[j] 放到 i 的位置，在下一轮循环继续处理
                    swap(nums[i], nums[j]); 

                    // 使用负号标记上，现在 j 位置存储的元素已经是正确的元素了 
                    nums[j] = -nums[j]; 
                }
            }

        for(int& e: nums) e = -e;
        return nums;
    }
};
```
python实现：
```python
from typing import List

class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        """
        使用循环置换和负号标记实现 O(1) 空间复杂度的数组重排。

        核心思想:
        1. 遍历数组，如果一个元素 nums[i] 是正数，说明它还未被放置到最终位置。
        2. 我们就开启一个“循环置换”链条：
           a. 计算当前元素应该去的最终位置 j。
           b. 将当前元素与位置 j 的元素交换。
           c. 那个被换到位置 j 的元素现在是正确的了，我们将其变为负数来“标记”它已就位。
           d. 交换后，原位置 i 有了一个新元素，我们继续为这个新元素寻找它的归宿，直到循环闭合。
        3. 所有元素都就位后，它们都是负数，最后再遍历一次将它们全部转回正数。

        """
        
        # 步骤 1: 遍历并处理每一个位置，形成置换环
        for i in range(2 * n):
            # 如果 nums[i] > 0，说明这个位置的元素或被换到这个位置的元素还未被处理
            if nums[i] > 0:
                # j 追踪的是当前处理的这个数字的“原籍”索引。
                # 比如，我们处理 5，它的原籍是索引 1。当 5 被换走，1 过来了，
                # 我们继续处理 1，但需要知道 1 的原籍是索引 2，这时 j 就起作用了。
                j = i
                
                # 开启一个置换循环，直到一个本就属于 i 位置的元素被换回来
                while nums[i] > 0:
                    # 根据“原籍”索引 j，计算出它应该去的目标位置
                    # 这是 Python 的三元表达式写法
                    target_idx = 2 * j if j < n else 2 * (j - n) + 1
                    
                    # 把当前在 i 位置的“待安置”元素，与它目标位置的元素交换
                    # 此时，nums[i] 得到一个新元素，nums[target_idx] 得到了它正确的元素
                    nums[i], nums[target_idx] = nums[target_idx], nums[i]
                    
                    # 将刚刚被正确安放的元素 nums[target_idx] 标记为负数，表示“已处理”
                    nums[target_idx] = -nums[target_idx]
                    
                    # 更新“原籍”索引，为下一次循环做准备
                    j = target_idx

        # 步骤 2: 清理标记，将所有数字恢复为正数
        for i in range(2 * n):
            nums[i] = -nums[i]
            
        return nums
```

## 复杂度分析

该算法完全在输入数组上进行操作，没有使用任何随输入规模 n 增长的额外数据结构。因此空间复杂度是常数级别。

这看起来像一个嵌套循环，可能会让人误以为是 $O(n^2)$。但实际上，每个数组元素只会被访问和移动一次。
`if(nums[i] > 0)` 这个判断确保了每个元素所在的环只会被处理一遍。一旦一个元素被 swap 到正确的位置并被标记为负数，它就再也不会触发 while 循环了。
整个算法中，每个元素 `nums[k]` 只会被 swap 一次（当它被放到正确位置时），也只会被标记（变负）一次。因此，所有 while 循环的总迭代次数加起来是 $O(n)$ 级别。
所以，总的时间复杂度是 $O(n)$。

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

# 我的

```python
class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        ans = []
        for i in range(n):
            ans.append(nums[i])
            ans.append(nums[i+n])
        return ans
```

## 复杂度分析

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$
