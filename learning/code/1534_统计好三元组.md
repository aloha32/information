# 2025.8.17 （前缀和理解了一些，三指针还没看懂）

给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量。

如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 。

- 0 <= i < j < k < arr.length
- |arr[i] - arr[j]| <= a
- |arr[j] - arr[k]| <= b
- |arr[i] - arr[k]| <= c
其中 |x| 表示 x 的绝对值。

返回 好三元组的数量 。

 
```
示例 1：

输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
输出：4
解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。
```
```
示例 2：

输入：arr = [1,1,2,2,3], a = 0, b = 0, c = 1
输出：0
解释：不存在满足所有条件的三元组。
```

提示：

- 3 <= arr.length <= 100
- 0 <= arr[i] <= 1000
- 0 <= a, b, c <= 1000

# 灵神

## 前缀和
### 关键思路
> 注：本文中的「子数组」均表示「连续子数组」。

比如 $nums=[1,2,3,4,5,6]$，要想计算子数组 $[3,4,5]$ 的元素和，可以用前缀 $[1,2,3,4,5]$ 的元素和，减去另一个前缀 $[1,2]$ 的元素和，就得到了子数组 $[3,4,5]$ 的元素和，即

$$3+4+5=(1+2+3+4+5)−(1+2)$$

换句话说，把前缀 $[1,2,3,4,5]$ 的前缀 $[1,2]$ 去掉，就得到了子数组 $[3,4,5]$。

一般地，任意子数组都是一个前缀去掉前缀后的结果。所以任意子数组的和，都可以表示为两个前缀和的差。

nums 的子数组有 $O(n^2)$ 个，但只有 $O(n)$ 个前缀。那么，预处理 nums 的所有前缀和，就可以 $O(1)$ 计算任意子数组的元素和。

### 具体思路
为方便描述，把 nums 记作 a，设其长度为 n。

对于数组 a，计算它的长为 n+1 的前缀和数组 s，即 a 的前 0 个数的和，前 1 个数的和，前 2 个数的和……前 n 个数的和。

<img width="406" height="281" alt="image" src="https://github.com/user-attachments/assets/7e1af160-c0d1-4a57-9547-99b67a68e11c" />

根据这个定义，前 i 个数的和，加上 a[i]，就是前 i+1 个数的和，即

$$s[i+1]=s[i]+a[i]$$

示例中的数组 $[−2,0,3,−5,2,−1]$，对应的前缀和数组 $s=[0,−2,−2,1,−4,−2,−3]$。

通过前缀和，我们可以把子数组的元素和转化成两个前缀和的差，下标区间 [left,right] 的元素和等于前缀 [0,right] 的元素和减去另一个前缀 [0,left−1] 的元素和，即

$$s[right+1]−s[left]$$

有了这个式子，示例中子数组 $[3,−5,2,−1]$ 的和，就可以 O(1) 地用 $s[6]−s[2]=−3−(−2)=−1$ 算出来。

### 为什么要定义 $s[0]=0$

如果 `left=0`，要计算的子数组是一个前缀（从 `a[0]` 到 `a[right]`）。按照公式，我们要用 `s[right+1]` 减去 `s[0]`。

如果不定义 `s[0]=0`，就必须特判 `left=0` 的情况了。通过定义 `s[0]=0`，任意子数组（包括前缀）都可以表示为两个前缀和的差。

此外，如果 a 是空数组，定义 `s[0]=0` 的写法是可以兼容这种情况的。

### 回到本题

枚举j和k，可以确定 $A_i$ 的范围。
- $|A_i - A_j| <= a$ -> $A_j - a <= A_i <= A_j + a$
- $|A_i - A_k| <= c$ -> $A_k - c <= A_i <= A_k + c$
- $0 <= A_i <= max(A)$

综合这三个区间（取交集），得到 $A_i$ 的范围为：

$$
[max(A_j -a , A_k - c , 0 ),min(A_j + a , A_k + c , max(A))]
$$

如果交集为空，则没有符合要求的 $A_i$

#### 如何计算交集中的 $A_i$ 的个数？

需要指导每个 $A_i$ 的出现次数，记录到一个cnt数组中。例如：0出现3次，1出现2次，3出现4次，则

$$
cnt = [3,2,0,4....]
$$

统计范围中有多少个数，等价于求 cnt 的子数组的元素和。比如 [1,3] 范围中的元素个数，就是 `cnt[1]+cnt[2]+cnt[3]`。通过维护 cnt 数组的 **前缀和** 数组 s，就可以 `O(1)` 计算 cnt 的子数组和了。

代码实现时，无需维护 cnt，而是直接维护 s：

根据前缀和的递推式 $s[i+1]=s[i]+cnt[i]$ ，如果`cnt[i]`加一了，那么下标 `>=i+1` 的前缀和都要加一。
```python
class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        mx = max(arr)
        s = [0] * (mx + 2)  # cnt 数组的前缀和
        ans = 0
        for j, y in enumerate(arr):
            for z in arr[j + 1:]:
                if abs(y - z) > b:
                    continue
                l = max(y - a, z - c, 0)
                r = min(y + a, z + c, mx)
                ans += max(s[r + 1] - s[l], 0)  # 如果 l > r + 1，s[r + 1] - s[l] 可能是负数
            for v in range(y + 1, mx + 2):
                s[v] += 1  # 把 y 加到 cnt 数组中，更新所有受到影响的前缀和
        return ans
```
这里的 s[t] 表示“截至当前 j 之前，值 < t 的元素个数”（计数数组的前缀和）

### 复杂度分析
- 时间复杂度： $O(n(n+U))$
- 空间复杂度： $O(U)$
- n是arr的长度， $U=max(arr)$

把整个过程（`arr =[3,0,1,1,9,7]，a=7,b=2,c=3`）从头到尾**逐步**梳理一遍，保证每一步都对齐到代码逻辑：

### j = 0，y = 3（此时“之前元素”为空）

* 内层枚举 z ∈ `[0,1,1,9,7]`：即便满足 `|y-z|<=b`，此时 `s` 全 0，贡献都是 0。`ans` 仍为 0。
* 更新 `s`：对 `v ∈ [4, 11)` 加 1 ⇒ `s = [0,0,0,0,1,1,1,1,1,1,1]`.

---

### j = 1，y = 0（“之前元素”只有 3）

* 枚举 `z ∈ [1,1,9,7]`，b=2：

  1. `z=1`（k=2），`|0-1|=1≤2`：
     `l = max(y-a, z-c, 0) = max(-7, -2, 0) = 0`
     `r = min(y+a, z+c, mx) = min(7, 4, 9) = 4`
     贡献 = `s[r+1]-s[l] = s[5]-s[0] = 1-0 = 1`  ← 这里就是关键：**`s[5]` 已是 1，不是 0！**
     `ans = 1`
  2. `z=1`（k=3），同理再加 1：`ans = 2`
  3. `z=9`：`|0-9|=9>2` 跳过
  4. `z=7`：`|0-7|=7>2` 跳过
* 更新 `s`：对 `v ∈ [1, 11)` 加 1 ⇒
  `s = [0,1,1,1,2,2,2,2,2,2,2]`

---

### j = 2，y = 1（“之前元素”为 3、0）

* 枚举 `z ∈ [1,9,7]`：

  1. `z=1`（k=3），`|1-1|=0≤2`：
     `l = max(1-7, 1-3, 0) = 0`，`r = min(8, 4, 9) = 4`
     贡献 = `s[5]-s[0] = 2-0 = 2`（对应 i=0 的值 3、i=1 的值 0，均落在 \[0,4]）
     `ans = 2 + 2 = 4`
  2. `z=9`：`|1-9|=8>2` 跳过
  3. `z=7`：`|1-7|=6>2` 跳过
* 更新 `s`：对 `v ∈ [2, 11)` 加 1 ⇒
  `s = [0,1,2,2,3,3,3,3,3,3,3]`

---

### j = 3，y = 1（“之前元素”为 3、0、1）

* 枚举 `z ∈ [9,7]`：两者与 y 的差都大于 b=2，均跳过，`ans` 不变（仍 4）。
* 更新 `s`：对 `v ∈ [2, 11)` 再加 1 ⇒
  `s = [0,1,3,3,4,4,4,4,4,4,4]`

---

### j = 4，y = 9（“之前元素”为 3、0、1、1）

* 枚举 `z ∈ [7]`，`|9-7|=2≤2`：
  `l = max(9-7, 7-3, 0) = max(2,4,0) = 4`
  `r = min(9+7, 7+3, 9) = min(16,10,9) = 9`
  贡献 = `s[10]-s[4] = 4 - 4 = 0`（之前的值只有 3、0、1、1，都不在区间 \[4,9] 内）
  `ans` 仍为 4。
* 更新 `s`：对 `v ∈ [10, 11)` 加 1 ⇒
  `s = [0,1,3,3,4,4,4,4,4,4,5]`

---

### j = 5，y = 7

* 后面已无 `z`，结束。最终 `ans = 4`。


## 排序 + 枚举中间 + 三指针

如果 $A_i <= 10^9$ ，前缀和方法会超时，能否做到时间复杂度和U无关？

如果 A 是有序的就好了，这样有更好的性质方便我们计算。

直接排序？不行，题目要求 i<j<k，不能打乱顺序。

改成创建一个 `[0,n−1]` 的下标数组 idx，对下标数组按照 $A_i$ 的值从小到大排序。

然后遍历 idx 的元素，作为下标 j。（枚举中间）

- 把满足 $i<j$ 且 $|A_i - A_j|<=a$ 的 $A_i$ 保存到数组left中
- 把满足 $k>j$ 且 $|A_k - A_j|<=b$ 的 $A_k$ 保存到数组right中

由于排序了，我们得到的是两个有序数组。现在问题变成：给定两个有序数组，从两个数组中各选一个数，计算绝对差 $≤c$ 的数对个数。

遍历 left 中的元素 x，计算 right 中有多少个元素 z 满足 $|x-z|<=c$ ，也就是在 $[x-c,x+c]$ 中z的个数。

类似于前缀和的思路，这等价于：right 中的 $≤x+c$ 的元素个数，减去 right 中的 $<x−c$ 的元素个数。

这可以用三指针解决：
1. 初始化 $K_1 = K_2 = 0$
2. 遍历 left 中的元素 x
3. 如果 $right[K_2]<=x+c$ ，那么增大 $K_2$ ，直到不满足。 此时 $K_2$ 就是right中的 $<=x+c$ 的元素个数
4. 如果 $right[K_1]<x-c$ ，那么增大 $K_1$ ，直到不满足。 此时 $K_1$ 就是right中的 $<x-c$ 的元素个数
5. 把 $K_2 - K_1$ 加入答案

```python
class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        idx = sorted(range(len(arr)), key=lambda i: arr[i])

        ans = 0
        for j in idx:
            y = arr[j]
            left = [arr[i] for i in idx if i < j and abs(arr[i] - y) <= a]
            right = [arr[k] for k in idx if k > j and abs(arr[k] - y) <= b]

            k1 = k2 = 0
            for x in left:
                while k2 < len(right) and right[k2] <= x + c:
                    k2 += 1
                while k1 < len(right) and right[k1] < x - c:
                    k1 += 1
                ans += k2 - k1
        return ans
```

### 复杂度分析
- 时间复杂度： $O(n^2)$ ，其中n 是 arr 的长度。三指针的二重循环，最内层循环中对 $K_1$ 和 $K_2$ 加一的总执行次数不会超过 2n 次,所以内部的二重循环的时间复杂度为 $O(n)$ , 总的时间复杂度是 $O(n^2)$
- 空间复杂度： $O(n)$ 

# 暴力

```python
class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        n = len(arr)
        ans = 0
        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j + 1, n):
                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:
                        ans += 1
        return ans
```

## 复杂度分析

- 时间复杂度： $O(n^3)$
- 空间复杂度： $O(1)$
