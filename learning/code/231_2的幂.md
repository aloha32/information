# 2025.8.19
给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。

 
```
示例 1：

输入：n = 1
输出：true
解释：20 = 1
```
```
示例 2：

输入：n = 16
输出：true
解释：24 = 16
```
```
示例 3：

输入：n = 3
输出：false
```

提示：

- -231 <= n <= 231 - 1
 

进阶：你能够不使用循环/递归解决此问题吗？

# 灵神：位运算

如果 n 是 2 的幂，那么 n 的二进制是非常特殊的，形如 100⋯0。例如 4=100 ， 8 = 1000 ， 16 = 10000 。

如果 n 是 2 的幂，把 n 减 1 会使 n 的最高位变成 0，其余位变成 1，所以 `n&(n−1)` 一定是 0。

> 注：`n&(n−1)` 相当于去掉 n 二进制的最低位，可以用这个技巧枚举 n 中的比特 1。

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and n & (n - 1) == 0
```

## 复杂度分析

- 时间复杂度： $O(1)$
- 空间复杂度： $O(1)$

# 我的解法

幂次的逆运算为log，精度变换可以去除小数点

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n > 0:
            if (n - 2**int(log2(n))) == 0:
                return True
        return False
```

## 复杂度分析

- 时间复杂度： $O(1)$
- 空间复杂度： $O(1)$

2的幂次方在二进制表示中只有一个1,在 Python 中，我们可以很方便地使用内置的 bin() 函数和字符串的 .count() 方法来实现这个逻辑。

```python
class Solution:
    def isPowerOfTwo_binary_count(self, n: int) -> bool:
        # 1. 处理非正数
        if n <= 0:
            return False
        
        # 2. 将n转换为二进制字符串。
        #    注意：bin(16)会返回 '0b10000'，前面有'0b'前缀。
        binary_representation = bin(n)
        
        # 3. 统计字符串中'1'的个数
        # 4. 如果个数为1，则返回True
        return binary_representation.count('1') == 1

```

## 复杂度分析

将一个整数 n 转换为二进制字符串，需要的时间与 n 的二进制表示的长度成正比。一个整数 n 的二进制长度大约是 log₂(n)。
同样，.count('1') 方法需要遍历整个生成的字符串，其长度也是 log₂(n)。
因此，总的时间复杂度为 O(log n)。

这个方法需要创建一个新的字符串 binary_representation 来存储 n 的二进制形式。
这个字符串的长度与 log₂(n) 成正比。因此，算法需要 O(log n) 的额外空间。

- 时间复杂度： $O(log n)$
- 空间复杂度： $O(log n)$

# 常规思路

如果一个数 n 是 2 的幂次方，那么它一定是一个正数，并且不断地将它除以 2，最终会得到 1。在这个过程中，每一步的结果都必须是偶数，直到最后变成 1。

循环：
```python
class Solution:
    def isPowerOfTwo_iterative(self, n: int) -> bool:
        # 2的幂次方必须是正数
        if n <= 0:
            return False
        
        # 不断将偶数n除以2
        while n % 2 == 0:
            n = n // 2  # 使用整数除法
            
        # 如果n最终等于1，说明它是2的幂次方
        return n == 1

```

## 复杂度分析

- 时间复杂度： $O(log n)$
- 空间复杂度： $O(1)$

递归：
```python
class Solution:
    def isPowerOfTwo_recursive(self, n: int) -> bool:
        # 基本情况：处理非正数
        if n <= 0:
            return False
            
        # 基本情况：成功终止条件
        if n == 1:
            return True
        
        # 基本情况：失败终止条件，如果n是大于1的奇数
        if n % 2 != 0:
            return False
            
        # 递归步骤：n是偶数，问题规模缩小一半
        return self.isPowerOfTwo_recursive(n // 2)

```

## 复杂度分析

- 时间复杂度： $O(log n)$
- 空间复杂度： $O(log n)$
