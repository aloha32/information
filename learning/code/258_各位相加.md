# 2025.8.18
给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。
```
示例 1:

输入: num = 38
输出: 2 
解释: 各位相加的过程为：
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2
由于 2 是一位数，所以返回 2。
```
```
示例 2:

输入: num = 0
输出: 0
```

提示：

- 0 <= num <= 231 - 1
 

进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？

# 灵神

比如 `num=678`，计算过程为

$$
678->6+7+8=21->2+1=3
$$

从 678 到 21，减少了多少？

$$
678-21
=(600+70+8)-(6+7+8)
=(600-6)+(70-7)+(8-8)
=6*(100-1)+7*(10-1)
=6*99 + 7*9
$$

99 和 9 都是 9 的倍数，所以减少量一定为 9 的倍数

从21到3 ，减少量也是9的倍数

由于减少量总是 9 的倍数，只看结果的话，相当于从 678 开始，不断地减 9，直到减成个位数（小于 10 的数）。

与【余数】的概念类似：从 num 开始，不断地减 9，直到小于 9，所得到的结果叫做 num 除以 9 的余数，即 `num mod 9`。

<img width="308" height="115" alt="image" src="https://github.com/user-attachments/assets/6224091d-d049-49f3-b8c0-c3c206aa54f5" />

总结为公式： `(num - 1) mod 9 + 1` ， 对0也适用

> 对于 Python 来说，−1mod9=8，所以 Python 需要特判 num=0 的情况。

```python
class Solution:
    def addDigits(self, num: int) -> int:
        return (num - 1) % 9 + 1 if num else 0
```

## 复杂度分析

- 时间复杂度： $O(1)$
- 空间复杂度： $O(1)$

# 暴力

```python
class Solution:
    def addDigits(self, num: int) -> int:
        def do_add(s_new:str) -> str:
            s_added = s_new[0]
            for i in range(1,len(s_new)):
                s_added = str(int(s_new[i]) + int(s_added))
            return s_added
        s = str(num)
        s_new = '0' + s
        while int(s_new) >= 10 :
            s_new = do_add(s_new)
        return int(s_new)
```

## 复杂度分析

- 时间复杂度： $O(log(num) * log(log(num)))$  , num为输入数字
- 空间复杂度： $O(log(num))$
