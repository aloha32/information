# 2025.8.20
给你一个二维整数数组 matrix， 返回 matrix 的 转置矩阵 。

矩阵的 转置 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。

<img width="3184" height="1045" alt="image" src="https://github.com/user-attachments/assets/15449b8a-821c-4790-ac66-a10cc9cc46c9" />

```
示例 1：

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[1,4,7],[2,5,8],[3,6,9]]
```
```
示例 2：

输入：matrix = [[1,2,3],[4,5,6]]
输出：[[1,4],[2,5],[3,6]]
```

提示：

- m == matrix.length
- n == matrix[i].length
- 1 <= m, n <= 1000
- 1 <= m * n <= 105
- -109 <= matrix[i][j] <= 109

# 灵神
## python3库函数

分解成三个部分：`*` 操作符（星号或解包操作符）、`zip()` 函数和 `list()` 构造函数。

在函数调用时，`*` 放在一个可迭代对象（如列表）前面，它的作用是“解包”这个可迭代对象，将其中的每个元素作为独立的参数传递给函数。

`zip()` 是一个内置函数，它接收一个或多个可迭代对象作为参数，然后将这些对象中对应位置的元素打包成一个个元组（tuple），最后返回一个包含这些元组的迭代器（iterator）。 `zip()` 会在最短的可迭代对象被耗尽时停止。



举例：

```python
matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
```
当执行 `zip(*matrix)` 时，`*matrix` 会将 matrix 中的每个子列表（即每一行）解包出来，作为独立的参数传给 `zip()` 函数。
因此，`zip(*matrix)` 等价于：`zip([1, 2, 3], [4, 5, 6], [7, 8, 9])`， 
`zip()` 函数会执行以下操作：取出每个参数的第 0 个元素 `(1, 4, 7)` 并将它们打包成一个元组 `(1, 4, 7)`。
取出每个参数的第 1 个元素 `(2, 5, 8)` 并将它们打包成一个元组 `(2, 5, 8)`。
取出每个参数的第 2 个元素 `(3, 6, 9)` 并将它们打包成一个元组 `(3, 6, 9)`。
执行完 `zip(*matrix)` 后，我们得到一个 zip 对象（一个迭代器），它包含了 `(1, 4, 7), (2, 5, 8), (3, 6, 9)`。

`zip()` 函数返回的是一个迭代器，而不是一个列表。
为了得到最终的列表结构，我们需要用 `list()` 构造函数来遍历这个迭代器，并将其所有元素（即 zip 生成的元组）收集到一个新的列表中。

```python
class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        return list(zip(*matrix))
```

`zip()` 函数和 `*` 操作符都是用 C 语言实现的，执行效率很高。同时，由于 `zip()` 返回迭代器，内存使用也得到了优化。

### 复杂度分析

- 时间复杂度： $O(m*n)$
- 空间复杂度： $O(m*n)$



# 我的

学到了如何创建一个n行m列的二维列表

```python
class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0])
        ans = [[0 for _ in range(m)] for _ in range(n)]
        for i in range(m):
            for j in range(n):
                    ans[j][i]= matrix[i][j]
        return ans
```

## 复杂度分析

- 时间复杂度： $O(m*n)$
- 空间复杂度： $O(m*n)$
