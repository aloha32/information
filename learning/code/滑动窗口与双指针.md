# 2025.8.21

# 2025.8.22

## 定长滑窗

### 1456.定长子串中元音的最大数目
给你字符串 s 和整数 k 。

请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。

英文中的 元音字母 为（a, e, i, o, u）。

```
示例 1：

输入：s = "abciiidef", k = 3
输出：3
解释：子字符串 "iii" 包含 3 个元音字母。
```
```
示例 2：

输入：s = "aeiou", k = 2
输出：2
解释：任意长度为 2 的子字符串都包含 2 个元音字母。
```
```
示例 3：

输入：s = "leetcode", k = 3
输出：2
解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。
```
```
示例 4：

输入：s = "rhythms", k = 4
输出：0
解释：字符串 s 中不含任何元音字母。
```
```
示例 5：

输入：s = "tryhard", k = 4
输出：1
```

提示：

- 1 <= s.length <= $10^5$
- s 由小写英文字母组成
- 1 <= k <= s.length

### 核心思想

我们要计算所有长度恰好为 k 的子串中，最多可以包含多少个元音字母。
对于下图的字符串 abci，假如我们已经计算出了子串 abc 的元音个数，
那么从子串 abc 到子串 bci，只需要考虑移除（离开窗口）的字母 a 是不是元音，以及添加（进入窗口）的字母 i 是不是元音即可，
因为中间的字母 b 和 c 都在这两个子串中。

<img width="347" height="452" alt="image" src="https://github.com/user-attachments/assets/a7c684d8-7b2c-4d07-b566-a43701508c5c" />

[灵神教学](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/2809359/tao-lu-jiao-ni-jie-jue-ding-chang-hua-ch-fzfo/)

### 套路
从左到右遍历字符串，所以需要知道字符串开头和结尾的位置，也就是左指针和右指针。经过观察或实验后，可以发现，由于字符串长度为 k ，则`R - L + 1 = k `。

三步走：**入-更新-出**

1. **入**： 下标为i的元素进入窗口，更新相关统计量。
如果窗口左指针 `i - k + 1 < 0` ， 也就是 `i < k - 1` ，则尚未形成第一个窗口，需要重复第一步。 
2. **更新**： 更新答案，一般为更新最大值/最小值。
3. **出**： 下标为 `i - k + 1` 的元素离开窗口，更新相关统计量，为下一次循环做准备。

以上三步适用于所有定长滑窗题目。

#### 为什么窗口右端点为 i 的时候，左端点是 `i−k+1`？
对于窗口（闭区间）`[L,R]` 来说，`[L,R]` 里面的元素个数为 `R−L+1`。

比如 `[2,5]` 里面有 $2,3,4,5$ 一共 $5−2+1=4$ 个数。

如果窗口大小为 `k`，即 `R−L+1=k`，解得 `L=R−k+1`。所以右端点为 `R` 的时候，左端点为 `R−k+1`。

```python
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        ans = vowel = 0
        for i, c in enumerate(s):
            # 1. 进入窗口
            if c in "aeiou":
                vowel += 1
            if i < k - 1:  # 窗口大小不足 k
                continue
            # 2. 更新答案
            ans = max(ans, vowel)
            if ans == k:
                break
            # 3. 离开窗口，为下一个循环做准备
            if s[i - k + 1] in "aeiou":
                vowel -= 1
        return ans
```

## 复杂度分析

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

### 643.子数组最大平均数 I
给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。

请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。

任何误差小于 $10^-5$ 的答案都将被视为正确答案。

 
```
示例 1：

输入：nums = [1,12,-5,-6,50,3], k = 4
输出：12.75
解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75
```
```
示例 2：

输入：nums = [5], k = 1
输出：5.00000
```

提示：

- n == nums.length
- 1 <= k <= n <= 105
- -104 <= nums[i] <= 104

```python
class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        n = len(nums)
        # print(n)
        sum = 0
        if n == k:
            for i in range(n):
                sum += nums[i]
            ans = sum / k
        else:
            ans = 0
            for i,c in enumerate(nums):
                left = i - k + 1
                sum += c
                if left < 0:
                    continue
                avg = sum/k
                if avg < 0 and ans == 0:
                    ans = min(ans,avg)
                else:
                    ans = max(ans,avg)
                sum -= nums[left] 
        return ans
```
灵神：负无穷大和return是精髓
```python
class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        max_s = -inf  # 窗口元素和的最大值（负无穷大）
        s = 0  # 维护窗口元素和
        for i, x in enumerate(nums):
            # 1. 进入窗口
            s += x
            if i < k - 1:  # 窗口大小不足 k
                continue
            # 2. 更新答案
            max_s = max(max_s, s)
            # 3. 离开窗口
            s -= nums[i - k + 1]
        return max_s / k
```

## 复杂度分析

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$


### 1343.大小为 K 且平均值大于等于阈值的子数组数目
给你一个整数数组 arr 和两个整数 k 和 threshold 。

请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。

 
```
示例 1：

输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
输出：3
解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。
```
```
示例 2：

输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
输出：6
解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。
```

提示：

- 1 <= arr.length <= $10^5$
- 1 <= arr[i] <= $10^4$
- 1 <= k <= arr.length
- 0 <= threshold <= $10^4$

```python
class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        n = len(arr)
        ans = sum = 0
        for i,c in enumerate(arr):
            left = i - k + 1
            sum += c
            if left < 0:
                continue
            if sum/k >= threshold:
                ans += 1
            sum -= arr[left]
        return ans
```
灵神：除法可以转换为乘法
```python
class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        ans = s = 0  # 维护窗口元素和
        for i, x in enumerate(arr):
            # 1. 进入窗口
            s += x
            if i < k - 1:  # 窗口大小不足 k
                continue
            # 2. 更新答案
            if s >= k * threshold:
                ans += 1
            # 3. 离开窗口
            s -= arr[i - k + 1]
        return ans
```

## 复杂度分析

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

