# 二叉树的遍历方式
二叉树的遍历是指按照特定的顺序访问树中的每一个节点，确保每个节点只被访问一次。 主要的遍历方式分为两大类：深度优先遍历（Depth-First Traversal）和广度优先遍历（Breadth-First Traversal）。

二叉树的定义：
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
# 构建示例二叉树
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

```

## 深度优先遍历 (Depth-First Traversal, DFT)
深度优先遍历会尽可能深地搜索树的分支。 根据访问根节点的时机不同，深度优先遍历又分为三种主要类型：前序遍历、中序遍历和后序遍历。
### 前序遍历 (Pre-order Traversal)
根节点 → 左子树 → 右子树。
```python
def preorder_traversal(root):
    if root is None:
        return
    print(root.val, end=' ')  # 访问根节点
    preorder_traversal(root.left)  # 遍历左子树
    preorder_traversal(root.right) # 遍历右子树

# 调用
print("前序遍历:")
preorder_traversal(root)
# 输出: 1 2 4 5 3

```
### 中序遍历 (In-order Traversal)
左子树 → 根节点 → 右子树。
```python
def inorder_traversal(root):
    if root is None:
        return
    inorder_traversal(root.left)   # 遍历左子树
    print(root.val, end=' ')   # 访问根节点
    inorder_traversal(root.right)  # 遍历右子树

# 调用
print("\n中序遍历:")
inorder_traversal(root)
# 输出: 4 2 5 1 3

```
### 后序遍历 (Post-order Traversal)
左子树 → 右子树 → 根节点。
```python
def postorder_traversal(root):
    if root is None:
        return
    postorder_traversal(root.left)  # 遍历左子树
    postorder_traversal(root.right) # 遍历右子树
    print(root.val, end=' ')  # 访问根节点

# 调用
print("\n后序遍历:")
postorder_traversal(root)
# 输出: 4 5 2 3 1

```

## 广度优先遍历 (Breadth-First Traversal, BFT)
广度优先遍历，又称为层次遍历 (Level-order Traversal)，它会从上到下、从左到右逐层访问树的节点。 这种遍历方式通常需要借助队列（Queue）这种数据结构来实现。

访问过程：

1. 将根节点放入队列。
2. 当队列不为空时，执行循环： a. 从队列中取出一个节点。 b. 访问该节点。 c. 如果该节点有左子节点，则将其左子节点放入队列。 d. 如果该节点有右子节点，则将其右子节点放入队列。

```python
from collections import deque

def level_order_traversal(root):
    if root is None:
        return
    
    queue = deque([root]) # 创建一个队列并把根节点放进去
    
    while queue:
        node = queue.popleft() # 从队列头部取出一个节点
        print(node.val, end=' ')
        
        if node.left:
            queue.append(node.left) # 将左子节点放入队列尾部
        if node.right:
            queue.append(node.right) # 将右子节点放入队列尾部

# 调用
print("\n层次遍历:")
level_order_traversal(root)
# 输出: 1 2 3 4 5

```

# 哈希表的应用
哈希表（Hash Table），也常被称为散列表。

哈希表是一种通过哈希函数（Hash Function）来将键（Key）映射到存储位置（称为“桶”或“槽”，Bucket/Slot）的数据结构。这个映射关系使得我们能够以接近 O(1) 的常数时间复杂度来完成插入、删除和查找操作，效率极高。

核心思想是：

1. 哈希函数：一个能将任意长度的输入（键）通过计算转换成一个固定长度输出（哈希值或哈希码）的函数。理想情况下，不同的键应该映射到不同的索引。
2. 数组/桶：一个数组，用于存储数据。哈希值决定了数据应该存放在数组的哪个位置。
3. 冲突处理：由于不同的键可能会被哈希函数计算出相同的索引（这被称为“哈希冲突”），必须有一套机制来解决这个问题，常见的方法有链地址法（在冲突的索引位置维护一个链表）和开放地址法（当位置被占用时，去寻找下一个可用的位置）。

 Python 中的字典（dict）和集合（set）。
 ## 字典 (Dictionary / Map)：用于存储键值对（Key-Value）。通过键可以快速找到对应的值。
 ```python
# 创建一个存储学生信息的字典
student_grades = {}

# 插入/更新 (近似 O(1))
student_grades['Alice'] = 95
student_grades['Bob'] = 88
student_grades['Charlie'] = 72

# 查找 (近似 O(1))
print(f"Bob's grade is: {student_grades['Bob']}") # 输出: Bob's grade is: 88

# 删除 (近似 O(1))
del student_grades['Charlie']

# 检查键是否存在 (近似 O(1))
if 'Alice' in student_grades:
    print("Alice is in the record.")

```

## 集合 (Set)：用于存储不重复的元素。哈希表能确保元素的唯一性，并能快速检查一个元素是否存在于集合中。
```python
# 创建一个集合来存储唯一的单词
unique_words = set()

# 添加元素 (近似 O(1))
unique_words.add("hello")
unique_words.add("world")
unique_words.add("hello") # 重复添加 "hello"，但集合中只会有一个

print(unique_words) # 输出: {'world', 'hello'}

# 检查成员是否存在 (近似 O(1))
if "world" in unique_words:
    print("'world' is in the set.")

```


# 动态规划

# 深度优先搜索
