# 常见的数据结构

- 栈（Stack）：栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。
- 队列（Queue）：队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。
- 数组（Array）：数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。
- 链表（Linked List）：链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。
- 树（Tree）：树是典型的非线性结构，它是包括，2 个结点的有穷集合 K。
- 图（Graph）：图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。
- 堆（Heap）：堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。
- 散列表（Hash table）：散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。

# 插入排序

插入排序(InsertionSort)，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。

插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

插入排序的平均时间复杂度也是 $O(n^2)$ ，空间复杂度为常数阶 $O(1)$ ，具体时间复杂度和数组的有序性也是有关联的。

插入排序中，当待排序数组是**有序**时，是**最优**的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 N-1 次，时间复杂度为 $O(N)$ 。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 $O(n^2)$ 。

## 过程

第一轮：从第二位置的 6 开始比较，比前面 7 小，交换位置。
<img width="749" height="342" alt="image" src="https://github.com/user-attachments/assets/49f4f89f-457d-4c75-b7f7-4dff50289a9c" />

第二轮：第三位置的 9 比前一位置的 7 大，无需交换位置。
<img width="813" height="134" alt="image" src="https://github.com/user-attachments/assets/583d537e-5dd5-475e-ba7c-a5110f4f1415" />

第三轮：第四位置的 3 比前一位置的 9 小交换位置，依次往前比较。
<img width="730" height="478" alt="image" src="https://github.com/user-attachments/assets/ad4cff79-1a5d-44de-b4d1-4edf3d61b588" />

第四轮：第五位置的 1 比前一位置的 9 小，交换位置，再依次往前比较。
<img width="746" height="613" alt="image" src="https://github.com/user-attachments/assets/bf188615-fffb-441c-acfa-5107bfbe8e2f" />

......

## 实现

python:
```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr
```

cpp:
```cpp
#include <iostream>
#include <vector>

void insertionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
}
```

# 希尔排序

希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。

希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。

它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。

希尔排序时间复杂度是 $O(n^(1.3-2))$ ，空间复杂度为常数阶 $O(1)$ 。希尔排序没有时间复杂度为 $O(n(logn))$ 的快速排序算法快 ，因此对中等大小规模表现良好，但对规模非常大的数据排序不是最优选择，总之比一般 $O(n^2 )$ 复杂度的算法快得多。

## 过程

希尔排序目的为了**加快速度**改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。

在此我们选择增量 `gap=length/2`，缩小增量以 `gap = gap/2` 的方式，用序列 `{n/2,(n/2)/2...1}` 来表示。

（1）初始增量第一趟 gap = length/2 = 4
<img width="814" height="713" alt="image" src="https://github.com/user-attachments/assets/0865d9f7-716b-414c-b60e-20876fdd18a4" />

（2）第二趟，增量缩小为 2
<img width="589" height="366" alt="image" src="https://github.com/user-attachments/assets/c95d41c7-e401-4e3e-be66-7c10c60a6ab4" />

（3）第三趟，增量缩小为 1,得到最终排序结果
<img width="611" height="180" alt="image" src="https://github.com/user-attachments/assets/0a664ac0-025c-475a-9b8d-20997265fe7d" />

## 实现
python：
```python
def shell_sort(arr):
    n = len(arr)
    # 初始间隔设为数组长度的一半
    gap = n // 2
    
    # 逐渐缩小间隔
    while gap > 0:
        # 对每个间隔进行插入排序
        for i in range(gap, n):
            # 保存当前元素
            temp = arr[i]
            j = i
            
            # 将大于当前元素的项向后移动
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            
            # 将当前元素放到正确位置
            arr[j] = temp
        
        # 缩小间隔
        gap //= 2
    
    return arr
```
cpp：
```cpp
#include <iostream>
#include <vector>

void shellSort(std::vector<int>& arr) {
    int n = arr.size();
    // 初始间隔设为数组长度的一半
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 对每个间隔进行插入排序
        for (int i = gap; i < n; i++) {
            int temp = arr[i];
            int j;
            
            // 将大于当前元素的项向后移动
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            
            // 将当前元素放到正确位置
            arr[j] = temp;
        }
    }
}

```

# 归并排序

归并排序（Merge sort）是建立在归并操作上的一种有效、稳定的排序算法，该算法是采用分治法(Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

当有 n 个记录时，需进行 `logn` 轮归并排序，每一轮归并，其比较次数不超过 n，元素移动次数都是 n，因此，归并排序的时间复杂度为 $O(nlogn)$ 。归并排序时需要和待排序记录个数相等的存储空间，所以空间复杂度为 $O(n)$ 。

归并排序适用于数据量大，并且对稳定性有要求的场景。

## 过程

取两个输入数组 A 和 B，一个输出数组 C，以及三个计数器 i、j、k，它们初始位置置于对应数组的开始端。

`A[i]` 和 `B[j]` 中较小者拷贝到 C 中的下一个位置，相关计数器向前推进一步。

当两个输入数组有一个用完时候，则将另外一个数组中剩余部分拷贝到 C 中。
<img width="587" height="587" alt="image" src="https://github.com/user-attachments/assets/4995a742-3df6-4a6e-8da3-5cd40bea467b" />

自顶向下的归并排序，递归分组图示：
<img width="716" height="416" alt="image" src="https://github.com/user-attachments/assets/9ccb42b1-a177-446f-b06f-35b7274486af" />

对第三行两个一组的数据进行归并排序
<img width="701" height="312" alt="image" src="https://github.com/user-attachments/assets/c8d88f58-3902-43b2-b135-94cf5a149b3a" />

对第二行四个一组的数据进行归并排序
<img width="714" height="226" alt="image" src="https://github.com/user-attachments/assets/0e6fc9e6-a6fc-4d61-80e3-79aeeb6dc124" />

整体进行归并排序
<img width="688" height="99" alt="image" src="https://github.com/user-attachments/assets/358e661a-325c-441b-a835-edcaaffd3c91" />


## 实现

python:
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    # 分割数组
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    
    # 递归排序
    left = merge_sort(left)
    right = merge_sort(right)
    
    # 合并结果
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    # 比较并合并
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # 添加剩余元素
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# 使用示例
my_list = [5, 2, 4, 6, 1, 3]
sorted_list = merge_sort(my_list)
print(sorted_list)  # 输出: [1, 2, 3, 4, 5, 6]
```
cpp:
```cpp
#include <iostream>
#include <vector>

// 合并两个已排序的子数组
void merge(std::vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    // 创建临时数组
    std::vector<int> L(n1), R(n2);
    
    // 复制数据到临时数组
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];
    
    // 合并临时数组
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    
    // 复制剩余元素
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// 归并排序主函数
void mergeSort(std::vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        
        // 递归排序两半
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        
        // 合并
        merge(arr, left, mid, right);
    }
}

// 使用示例
int main() {
    std::vector<int> my_list = {5, 2, 4, 6, 1, 3};
    mergeSort(my_list, 0, my_list.size() - 1);
    
    for (int num : my_list) {
        std::cout << num << " ";
    }
    // 输出: 1 2 3 4 5 6
    return 0;
}
```





















































# 二叉树的遍历方式
二叉树的遍历是指按照特定的顺序访问树中的每一个节点，确保每个节点只被访问一次。 主要的遍历方式分为两大类：深度优先遍历（Depth-First Traversal）和广度优先遍历（Breadth-First Traversal）。

二叉树的定义：
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
# 构建示例二叉树
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

```

## 深度优先遍历 (Depth-First Traversal, DFT)
深度优先遍历会尽可能深地搜索树的分支。 根据访问根节点的时机不同，深度优先遍历又分为三种主要类型：前序遍历、中序遍历和后序遍历。
### 前序遍历 (Pre-order Traversal)
根节点 → 左子树 → 右子树。
```python
def preorder_traversal(root):
    if root is None:
        return
    print(root.val, end=' ')  # 访问根节点
    preorder_traversal(root.left)  # 遍历左子树
    preorder_traversal(root.right) # 遍历右子树

# 调用
print("前序遍历:")
preorder_traversal(root)
# 输出: 1 2 4 5 3

```
### 中序遍历 (In-order Traversal)
左子树 → 根节点 → 右子树。
```python
def inorder_traversal(root):
    if root is None:
        return
    inorder_traversal(root.left)   # 遍历左子树
    print(root.val, end=' ')   # 访问根节点
    inorder_traversal(root.right)  # 遍历右子树

# 调用
print("\n中序遍历:")
inorder_traversal(root)
# 输出: 4 2 5 1 3

```
### 后序遍历 (Post-order Traversal)
左子树 → 右子树 → 根节点。
```python
def postorder_traversal(root):
    if root is None:
        return
    postorder_traversal(root.left)  # 遍历左子树
    postorder_traversal(root.right) # 遍历右子树
    print(root.val, end=' ')  # 访问根节点

# 调用
print("\n后序遍历:")
postorder_traversal(root)
# 输出: 4 5 2 3 1

```

## 广度优先遍历 (Breadth-First Traversal, BFT)
广度优先遍历，又称为层次遍历 (Level-order Traversal)，它会从上到下、从左到右逐层访问树的节点。 这种遍历方式通常需要借助队列（Queue）这种数据结构来实现。

访问过程：

1. 将根节点放入队列。
2. 当队列不为空时，执行循环： a. 从队列中取出一个节点。 b. 访问该节点。 c. 如果该节点有左子节点，则将其左子节点放入队列。 d. 如果该节点有右子节点，则将其右子节点放入队列。

```python
from collections import deque

def level_order_traversal(root):
    if root is None:
        return
    
    queue = deque([root]) # 创建一个队列并把根节点放进去
    
    while queue:
        node = queue.popleft() # 从队列头部取出一个节点
        print(node.val, end=' ')
        
        if node.left:
            queue.append(node.left) # 将左子节点放入队列尾部
        if node.right:
            queue.append(node.right) # 将右子节点放入队列尾部

# 调用
print("\n层次遍历:")
level_order_traversal(root)
# 输出: 1 2 3 4 5

```

# 哈希表的应用
哈希表（Hash Table），也常被称为散列表。

哈希表是一种通过哈希函数（Hash Function）来将键（Key）映射到存储位置（称为“桶”或“槽”，Bucket/Slot）的数据结构。这个映射关系使得我们能够以接近 O(1) 的常数时间复杂度来完成插入、删除和查找操作，效率极高。

核心思想是：

1. 哈希函数：一个能将任意长度的输入（键）通过计算转换成一个固定长度输出（哈希值或哈希码）的函数。理想情况下，不同的键应该映射到不同的索引。
2. 数组/桶：一个数组，用于存储数据。哈希值决定了数据应该存放在数组的哪个位置。
3. 冲突处理：由于不同的键可能会被哈希函数计算出相同的索引（这被称为“哈希冲突”），必须有一套机制来解决这个问题，常见的方法有链地址法（在冲突的索引位置维护一个链表）和开放地址法（当位置被占用时，去寻找下一个可用的位置）。

 Python 中的字典（dict）和集合（set）。
 ## 字典 (Dictionary / Map)：用于存储键值对（Key-Value）。通过键可以快速找到对应的值。
 ```python
# 创建一个存储学生信息的字典
student_grades = {}

# 插入/更新 (近似 O(1))
student_grades['Alice'] = 95
student_grades['Bob'] = 88
student_grades['Charlie'] = 72

# 查找 (近似 O(1))
print(f"Bob's grade is: {student_grades['Bob']}") # 输出: Bob's grade is: 88

# 删除 (近似 O(1))
del student_grades['Charlie']

# 检查键是否存在 (近似 O(1))
if 'Alice' in student_grades:
    print("Alice is in the record.")

```

## 集合 (Set)：用于存储不重复的元素。哈希表能确保元素的唯一性，并能快速检查一个元素是否存在于集合中。
```python
# 创建一个集合来存储唯一的单词
unique_words = set()

# 添加元素 (近似 O(1))
unique_words.add("hello")
unique_words.add("world")
unique_words.add("hello") # 重复添加 "hello"，但集合中只会有一个

print(unique_words) # 输出: {'world', 'hello'}

# 检查成员是否存在 (近似 O(1))
if "world" in unique_words:
    print("'world' is in the set.")

```


# 动态规划（Dynamic Programming, 简称 DP）
动态规划的本质是将一个复杂的大问题分解成一系列更小的、相互关联的子问题，然后通过求解这些子问题来得到大问题的解。为了避免重复计算，它会将已经解决过的子问题的答案存储起来（这个过程称为“记忆化”），当再次需要这个子问题的解时，直接查表获取，而不是重新计算。

一个问题能够用动态规划来解决，通常需要满足以下两个核心特性：
- 重叠子问题 (Overlapping Subproblems)
在递归求解主问题的过程中，许多相同的子问题会被反复计算多次。动态规划通过将子问题的解存储在一个表格（通常是数组或哈希表）中来避免这种冗余计算。当再次遇到相同的子问题时，直接从表格中查找结果。

- 最优子结构 (Optimal Substructure)
一个问题的最优解包含了其子问题的最优解。换句话说，我们可以通过组合子问题的最优解，来构造出原问题的最优解。这个特性保证了动态规划策略的正确性。

通常，解决一个动态规划问题可以遵循以下四个步骤：
1. 定义状态 (State)：这是最关键的一步。你需要定义一个数组（通常称为 dp 数组），并明确 dp[i] 或 dp[i][j] 代表什么。这个状态定义必须能够清晰地描述原问题和子问题的解。例如，dp[i] 可能表示“爬到第 i 级台阶的方法总数”或“偷到第 i 间房子的最高金额”。
2. 找出状态转移方程 (State Transition Equation)：这是动态规划的核心。你需要找到 dp[i] 与 dp[i-1], dp[i-2] 等之前状态之间的关系。这个方程描述了如何从一个或多个已知的子问题的解，推导出当前问题的解。例如，dp[i] = dp[i-1] + dp[i-2]。
3. 初始化 (Initialization)：确定 dp 数组的初始值或边界条件。这是状态转移方程能够开始计算的基础。例如，dp[0] = 0，dp[1] = 1。
4. 确定计算顺序 (Order of Computation)：明确 dp 数组的填充方向。通常是从小到大（自底向上）进行计算，确保在计算 dp[i] 时，它所依赖的子问题 dp[i-1] 等都已经被计算出来了。

## 经典示例
### 斐波那契数列
斐波那契数列是最简单的动态规划入门问题。
F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n > 1)
#### 暴力递归（未使用 DP）
```python
def fib_recursive(n):
    if n <= 1:
        return n
    return fib_recursive(n-1) + fib_recursive(n-2)

```
#### 动态规划解法 (自底向上)
```python
def fib_dp(n):
    if n <= 1:
        return n
    
    # 1. 定义状态 (dp 数组)
    dp = [0] * (n + 1)
    
    # 3. 初始化
    dp[0] = 0
    dp[1] = 1
    
    # 4. 按顺序计算
    for i in range(2, n + 1):
        # 2. 状态转移方程
        dp[i] = dp[i-1] + dp[i-2]
        
    return dp[n]

print(f"斐波那契数 F(10) 是: {fib_dp(10)}") # 输出: 55

```

### 爬楼梯
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶？
分析：

- 要想到达第 n 阶，只有两种可能：从第 n-1 阶爬 1 步上来，或者从第 n-2 阶爬 2 步上来。
- 因此，到达第 n 阶的方法数 = 到达第 n-1 阶的方法数 + 到达第 n-2 阶的方法数。
- 这完全就是斐波那契数列的模式！

```python
def climb_stairs(n):
    if n <= 2:
        return n
    
    # dp[i] 表示爬到第 i 级台阶的方法数
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
        
    return dp[n]

print(f"爬 10 级台阶的方法有: {climb_stairs(10)} 种") # 输出: 89

```

### 0-1 背包问题
有 N 件物品和一个容量为 V 的背包。第 i 件物品的重量是 weight[i]，价值是 value[i]。求解将哪些物品装入背包，可使这些物品的重量总和不超过背包容量，且价值总和最大。每件物品只能选一次（0-1）。

1. 定义状态：dp[i][j] 表示从前 i 件物品中任意选择，放入容量为 j 的背包中所能获得的最大价值。

2. 状态转移方程：
当我们考虑第 i 件物品时，有两种选择：

- 不放入背包：那么最大价值就是只考虑前 i-1 件物品放入容量为 j 的背包中的价值，即 dp[i-1][j]。
- 放入背包：前提是当前背包容量 j 必须大于等于物品 i 的重量 weight[i-1]（假设物品索引从0开始）。如果可以放入，那么价值就是 dp[i-1][j - weight[i-1]]（即用剩余容量装前 i-1 件物品的最大价值）加上物品 i 本身的价值 value[i-1]。

我们需要在这两种选择中取最大值：
dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight[i-1]] + value[i-1])

3. 初始化：dp 数组所有元素初始化为 0。dp[0][...] 和 dp[...][0] 都为 0，表示没有物品或没有容量时，最大价值为 0。

4. 计算顺序：外层循环遍历物品（从 i=1 到 N），内层循环遍历背包容量（从 j=1 到 V）。

```python
def knapsack_01(weights, values, capacity):
    num_items = len(weights)
    
    # 1. 定义状态: dp[i][j]
    # dp 数组大小为 (num_items + 1) x (capacity + 1)
    dp = [[0 for _ in range(capacity + 1)] for _ in range(num_items + 1)]
    
    # 4. 按顺序计算
    for i in range(1, num_items + 1):
        for j in range(1, capacity + 1):
            # 获取当前物品的重量和价值 (索引需要 -1)
            weight = weights[i-1]
            value = values[i-1]
            
            # 如果当前背包容量装不下物品 i
            if j < weight:
                dp[i][j] = dp[i-1][j]
            else:
                # 2. 状态转移方程
                # 不放物品 i vs 放物品 i
                dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight] + value)
                
    return dp[num_items][capacity]

# 示例
weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
capacity = 8

max_value = knapsack_01(weights, values, capacity)
print(f"最大价值是: {max_value}") # 输出: 10 (选择重量为3和5的物品)

```
