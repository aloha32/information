# 常见的数据结构

- 栈（Stack）：栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。
- 队列（Queue）：队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。
- 数组（Array）：数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。
- 链表（Linked List）：链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。
- 树（Tree）：树是典型的非线性结构，它是包括，2 个结点的有穷集合 K。
- 图（Graph）：图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。
- 堆（Heap）：堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。
- 散列表（Hash table）：散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。

# 插入排序

插入排序(InsertionSort)，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。

插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

插入排序的平均时间复杂度也是 $O(n^2)$ ，空间复杂度为常数阶 $O(1)$ ，具体时间复杂度和数组的有序性也是有关联的。

插入排序中，当待排序数组是**有序**时，是**最优**的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 N-1 次，时间复杂度为 $O(N)$ 。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 $O(n^2)$ 。

## 过程

第一轮：从第二位置的 6 开始比较，比前面 7 小，交换位置。
<img width="749" height="342" alt="image" src="https://github.com/user-attachments/assets/49f4f89f-457d-4c75-b7f7-4dff50289a9c" />

第二轮：第三位置的 9 比前一位置的 7 大，无需交换位置。
<img width="813" height="134" alt="image" src="https://github.com/user-attachments/assets/583d537e-5dd5-475e-ba7c-a5110f4f1415" />

第三轮：第四位置的 3 比前一位置的 9 小交换位置，依次往前比较。
<img width="730" height="478" alt="image" src="https://github.com/user-attachments/assets/ad4cff79-1a5d-44de-b4d1-4edf3d61b588" />

第四轮：第五位置的 1 比前一位置的 9 小，交换位置，再依次往前比较。
<img width="746" height="613" alt="image" src="https://github.com/user-attachments/assets/bf188615-fffb-441c-acfa-5107bfbe8e2f" />

......

## 实现

python:
```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr
```

cpp:
```cpp
#include <iostream>
#include <vector>

void insertionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
}
```

# 希尔排序

希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。

希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。

它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。

希尔排序时间复杂度是 $O(n^(1.3-2))$ ，空间复杂度为常数阶 $O(1)$ 。希尔排序没有时间复杂度为 $O(n(logn))$ 的快速排序算法快 ，因此对中等大小规模表现良好，但对规模非常大的数据排序不是最优选择，总之比一般 $O(n^2 )$ 复杂度的算法快得多。







































# 二叉树的遍历方式
二叉树的遍历是指按照特定的顺序访问树中的每一个节点，确保每个节点只被访问一次。 主要的遍历方式分为两大类：深度优先遍历（Depth-First Traversal）和广度优先遍历（Breadth-First Traversal）。

二叉树的定义：
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
# 构建示例二叉树
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

```

## 深度优先遍历 (Depth-First Traversal, DFT)
深度优先遍历会尽可能深地搜索树的分支。 根据访问根节点的时机不同，深度优先遍历又分为三种主要类型：前序遍历、中序遍历和后序遍历。
### 前序遍历 (Pre-order Traversal)
根节点 → 左子树 → 右子树。
```python
def preorder_traversal(root):
    if root is None:
        return
    print(root.val, end=' ')  # 访问根节点
    preorder_traversal(root.left)  # 遍历左子树
    preorder_traversal(root.right) # 遍历右子树

# 调用
print("前序遍历:")
preorder_traversal(root)
# 输出: 1 2 4 5 3

```
### 中序遍历 (In-order Traversal)
左子树 → 根节点 → 右子树。
```python
def inorder_traversal(root):
    if root is None:
        return
    inorder_traversal(root.left)   # 遍历左子树
    print(root.val, end=' ')   # 访问根节点
    inorder_traversal(root.right)  # 遍历右子树

# 调用
print("\n中序遍历:")
inorder_traversal(root)
# 输出: 4 2 5 1 3

```
### 后序遍历 (Post-order Traversal)
左子树 → 右子树 → 根节点。
```python
def postorder_traversal(root):
    if root is None:
        return
    postorder_traversal(root.left)  # 遍历左子树
    postorder_traversal(root.right) # 遍历右子树
    print(root.val, end=' ')  # 访问根节点

# 调用
print("\n后序遍历:")
postorder_traversal(root)
# 输出: 4 5 2 3 1

```

## 广度优先遍历 (Breadth-First Traversal, BFT)
广度优先遍历，又称为层次遍历 (Level-order Traversal)，它会从上到下、从左到右逐层访问树的节点。 这种遍历方式通常需要借助队列（Queue）这种数据结构来实现。

访问过程：

1. 将根节点放入队列。
2. 当队列不为空时，执行循环： a. 从队列中取出一个节点。 b. 访问该节点。 c. 如果该节点有左子节点，则将其左子节点放入队列。 d. 如果该节点有右子节点，则将其右子节点放入队列。

```python
from collections import deque

def level_order_traversal(root):
    if root is None:
        return
    
    queue = deque([root]) # 创建一个队列并把根节点放进去
    
    while queue:
        node = queue.popleft() # 从队列头部取出一个节点
        print(node.val, end=' ')
        
        if node.left:
            queue.append(node.left) # 将左子节点放入队列尾部
        if node.right:
            queue.append(node.right) # 将右子节点放入队列尾部

# 调用
print("\n层次遍历:")
level_order_traversal(root)
# 输出: 1 2 3 4 5

```

# 哈希表的应用
哈希表（Hash Table），也常被称为散列表。

哈希表是一种通过哈希函数（Hash Function）来将键（Key）映射到存储位置（称为“桶”或“槽”，Bucket/Slot）的数据结构。这个映射关系使得我们能够以接近 O(1) 的常数时间复杂度来完成插入、删除和查找操作，效率极高。

核心思想是：

1. 哈希函数：一个能将任意长度的输入（键）通过计算转换成一个固定长度输出（哈希值或哈希码）的函数。理想情况下，不同的键应该映射到不同的索引。
2. 数组/桶：一个数组，用于存储数据。哈希值决定了数据应该存放在数组的哪个位置。
3. 冲突处理：由于不同的键可能会被哈希函数计算出相同的索引（这被称为“哈希冲突”），必须有一套机制来解决这个问题，常见的方法有链地址法（在冲突的索引位置维护一个链表）和开放地址法（当位置被占用时，去寻找下一个可用的位置）。

 Python 中的字典（dict）和集合（set）。
 ## 字典 (Dictionary / Map)：用于存储键值对（Key-Value）。通过键可以快速找到对应的值。
 ```python
# 创建一个存储学生信息的字典
student_grades = {}

# 插入/更新 (近似 O(1))
student_grades['Alice'] = 95
student_grades['Bob'] = 88
student_grades['Charlie'] = 72

# 查找 (近似 O(1))
print(f"Bob's grade is: {student_grades['Bob']}") # 输出: Bob's grade is: 88

# 删除 (近似 O(1))
del student_grades['Charlie']

# 检查键是否存在 (近似 O(1))
if 'Alice' in student_grades:
    print("Alice is in the record.")

```

## 集合 (Set)：用于存储不重复的元素。哈希表能确保元素的唯一性，并能快速检查一个元素是否存在于集合中。
```python
# 创建一个集合来存储唯一的单词
unique_words = set()

# 添加元素 (近似 O(1))
unique_words.add("hello")
unique_words.add("world")
unique_words.add("hello") # 重复添加 "hello"，但集合中只会有一个

print(unique_words) # 输出: {'world', 'hello'}

# 检查成员是否存在 (近似 O(1))
if "world" in unique_words:
    print("'world' is in the set.")

```


# 动态规划（Dynamic Programming, 简称 DP）
动态规划的本质是将一个复杂的大问题分解成一系列更小的、相互关联的子问题，然后通过求解这些子问题来得到大问题的解。为了避免重复计算，它会将已经解决过的子问题的答案存储起来（这个过程称为“记忆化”），当再次需要这个子问题的解时，直接查表获取，而不是重新计算。

一个问题能够用动态规划来解决，通常需要满足以下两个核心特性：
- 重叠子问题 (Overlapping Subproblems)
在递归求解主问题的过程中，许多相同的子问题会被反复计算多次。动态规划通过将子问题的解存储在一个表格（通常是数组或哈希表）中来避免这种冗余计算。当再次遇到相同的子问题时，直接从表格中查找结果。

- 最优子结构 (Optimal Substructure)
一个问题的最优解包含了其子问题的最优解。换句话说，我们可以通过组合子问题的最优解，来构造出原问题的最优解。这个特性保证了动态规划策略的正确性。

通常，解决一个动态规划问题可以遵循以下四个步骤：
1. 定义状态 (State)：这是最关键的一步。你需要定义一个数组（通常称为 dp 数组），并明确 dp[i] 或 dp[i][j] 代表什么。这个状态定义必须能够清晰地描述原问题和子问题的解。例如，dp[i] 可能表示“爬到第 i 级台阶的方法总数”或“偷到第 i 间房子的最高金额”。
2. 找出状态转移方程 (State Transition Equation)：这是动态规划的核心。你需要找到 dp[i] 与 dp[i-1], dp[i-2] 等之前状态之间的关系。这个方程描述了如何从一个或多个已知的子问题的解，推导出当前问题的解。例如，dp[i] = dp[i-1] + dp[i-2]。
3. 初始化 (Initialization)：确定 dp 数组的初始值或边界条件。这是状态转移方程能够开始计算的基础。例如，dp[0] = 0，dp[1] = 1。
4. 确定计算顺序 (Order of Computation)：明确 dp 数组的填充方向。通常是从小到大（自底向上）进行计算，确保在计算 dp[i] 时，它所依赖的子问题 dp[i-1] 等都已经被计算出来了。

## 经典示例
### 斐波那契数列
斐波那契数列是最简单的动态规划入门问题。
F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n > 1)
#### 暴力递归（未使用 DP）
```python
def fib_recursive(n):
    if n <= 1:
        return n
    return fib_recursive(n-1) + fib_recursive(n-2)

```
#### 动态规划解法 (自底向上)
```python
def fib_dp(n):
    if n <= 1:
        return n
    
    # 1. 定义状态 (dp 数组)
    dp = [0] * (n + 1)
    
    # 3. 初始化
    dp[0] = 0
    dp[1] = 1
    
    # 4. 按顺序计算
    for i in range(2, n + 1):
        # 2. 状态转移方程
        dp[i] = dp[i-1] + dp[i-2]
        
    return dp[n]

print(f"斐波那契数 F(10) 是: {fib_dp(10)}") # 输出: 55

```

### 爬楼梯
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶？
分析：

- 要想到达第 n 阶，只有两种可能：从第 n-1 阶爬 1 步上来，或者从第 n-2 阶爬 2 步上来。
- 因此，到达第 n 阶的方法数 = 到达第 n-1 阶的方法数 + 到达第 n-2 阶的方法数。
- 这完全就是斐波那契数列的模式！

```python
def climb_stairs(n):
    if n <= 2:
        return n
    
    # dp[i] 表示爬到第 i 级台阶的方法数
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
        
    return dp[n]

print(f"爬 10 级台阶的方法有: {climb_stairs(10)} 种") # 输出: 89

```

### 0-1 背包问题
有 N 件物品和一个容量为 V 的背包。第 i 件物品的重量是 weight[i]，价值是 value[i]。求解将哪些物品装入背包，可使这些物品的重量总和不超过背包容量，且价值总和最大。每件物品只能选一次（0-1）。

1. 定义状态：dp[i][j] 表示从前 i 件物品中任意选择，放入容量为 j 的背包中所能获得的最大价值。

2. 状态转移方程：
当我们考虑第 i 件物品时，有两种选择：

- 不放入背包：那么最大价值就是只考虑前 i-1 件物品放入容量为 j 的背包中的价值，即 dp[i-1][j]。
- 放入背包：前提是当前背包容量 j 必须大于等于物品 i 的重量 weight[i-1]（假设物品索引从0开始）。如果可以放入，那么价值就是 dp[i-1][j - weight[i-1]]（即用剩余容量装前 i-1 件物品的最大价值）加上物品 i 本身的价值 value[i-1]。

我们需要在这两种选择中取最大值：
dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight[i-1]] + value[i-1])

3. 初始化：dp 数组所有元素初始化为 0。dp[0][...] 和 dp[...][0] 都为 0，表示没有物品或没有容量时，最大价值为 0。

4. 计算顺序：外层循环遍历物品（从 i=1 到 N），内层循环遍历背包容量（从 j=1 到 V）。

```python
def knapsack_01(weights, values, capacity):
    num_items = len(weights)
    
    # 1. 定义状态: dp[i][j]
    # dp 数组大小为 (num_items + 1) x (capacity + 1)
    dp = [[0 for _ in range(capacity + 1)] for _ in range(num_items + 1)]
    
    # 4. 按顺序计算
    for i in range(1, num_items + 1):
        for j in range(1, capacity + 1):
            # 获取当前物品的重量和价值 (索引需要 -1)
            weight = weights[i-1]
            value = values[i-1]
            
            # 如果当前背包容量装不下物品 i
            if j < weight:
                dp[i][j] = dp[i-1][j]
            else:
                # 2. 状态转移方程
                # 不放物品 i vs 放物品 i
                dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight] + value)
                
    return dp[num_items][capacity]

# 示例
weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
capacity = 8

max_value = knapsack_01(weights, values, capacity)
print(f"最大价值是: {max_value}") # 输出: 10 (选择重量为3和5的物品)

```
